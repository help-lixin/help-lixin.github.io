I"ª<h3 id="1serverbootstrapç»§æ‰¿å…³ç³»">(1).ServerBootstrapç»§æ‰¿å…³ç³»</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>io.netty.bootstrap.ServerBootstrap 
    extends io.netty.bootstrap.AbstractBootstrap

// ServerBootstrapåªæ˜¯ç»§æ‰¿äº†:AbstractBootstrap
// AbstractBootstrap ä¸»è¦æ˜¯é’ˆå¯¹BossGroupçš„ä¸€äº›å‡½æ•°å®šä¹‰
// ServerBootstrap   ä¸»è¦æ˜¯é’ˆå¯¹WorkGroupçš„ä¸€äº›å‡½æ•°å®šä¹‰
</code></pre></div></div>

<h3 id="2serverbootstrapåˆ›å»ºä¸ä½¿ç”¨">(2).ServerBootstrapåˆ›å»ºä¸ä½¿ç”¨</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EventLoopGroup bossGroup = new NioEventLoopGroup(1);
EventLoopGroup workerGroup = new NioEventLoopGroup();
try {
    // 2.åˆ›å»ºServerBootstrap
    ServerBootstrap b = new ServerBootstrap();
    // 3.è¿›è¡Œé…ç½®
    // groupé…ç½®
    b.group(bossGroup, workerGroup)
     .channel(NioServerSocketChannel.class)
     .handler(new LoggingHandler(LogLevel.INFO))
    .childHandler(new TelnetServerInitializer(sslCtx));

    b.bind(PORT).sync().channel().closeFuture().sync();
} finally {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}
</code></pre></div></div>

<h3 id="3åˆ›å»ºserverbootstrap">(3).åˆ›å»ºServerBootstrap</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// æ— å‚æ„é€ å™¨
public ServerBootstrap() { }

</code></pre></div></div>

<h3 id="4serverbootstrapgroupé…ç½®">(4).ServerBootstrap.groupé…ç½®</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public ServerBootstrap group(EventLoopGroup group) {
    return group(group, group);
}

public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
    // 5. è°ƒç”¨çˆ¶ç±»:AbstractBootstrapæ„é€ å™¨
    super.group(parentGroup);
    
    if (this.childGroup != null) {
        throw new IllegalStateException("childGroup set already");
    }
    // æ„å»ºchildGroup
    this.childGroup = ObjectUtil.checkNotNull(childGroup, "childGroup");
    return this;
}
</code></pre></div></div>

<h3 id="5abstractbootstrapæ„é€ å™¨">(5).AbstractBootstrapæ„é€ å™¨</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>volatile EventLoopGroup group;

public B group(EventLoopGroup group) {
    ObjectUtil.checkNotNull(group, "group");
    if (this.group != null) {
        throw new IllegalStateException("group set already");
    }
    this.group = group;
    return self();
}
</code></pre></div></div>

<h3 id="6abstractbootstrapchannelé…ç½®">(6).AbstractBootstrap.channelé…ç½®</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public B channel(Class&lt;? extends C&gt; channelClass) {
    // channelClass = io.netty.channel.socket.nio.NioServerSocketChannel
    // 8.AbstractBootstrap.channelFactory
    return channelFactory(
        // 7.åˆ›å»ºReflectiveChannelFactory
        new ReflectiveChannelFactory&lt;C&gt;(ObjectUtil.checkNotNull(channelClass, "channelClass"))
    );
}
</code></pre></div></div>

<h3 id="7reflectivechannelfactory-æ„é€ å™¨">(7).ReflectiveChannelFactory æ„é€ å™¨</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public class ReflectiveChannelFactory&lt;T extends Channel&gt; implements ChannelFactory&lt;T&gt; {
    private final Constructor&lt;? extends T&gt; constructor;

    public ReflectiveChannelFactory(Class&lt;? extends T&gt; clazz) {
        ObjectUtil.checkNotNull(clazz, "clazz");
        try {
            this.constructor = clazz.getConstructor();
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException("Class " + StringUtil.simpleClassName(clazz) +
                    " does not have a public non-arg constructor", e);
        }
    } //end æ„é€ å™¨
    
    public T newChannel() {
        try {
            return constructor.newInstance();
        } catch (Throwable t) {
            throw new ChannelException("Unable to create Channel from class " + constructor.getDeclaringClass(), t);
        }
    } // end newChannel
}
</code></pre></div></div>

<h3 id="8abstractbootstrapchannelfactory">(8).AbstractBootstrap.channelFactory</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public B channelFactory(ChannelFactory&lt;? extends C&gt; channelFactory) {
    // channelFactory = ReflectiveChannelFactory(NioServerSocketChannel.class)
    ObjectUtil.checkNotNull(channelFactory, "channelFactory");
    
    if (this.channelFactory != null) { // false
        throw new IllegalStateException("channelFactory set already");
    }
    // è®¾ç½®Channelå·¥å‚
    this.channelFactory = channelFactory;
    return self();
}
</code></pre></div></div>

<h3 id="9abstractbootstraphandler-é…ç½®æ—¥å¿—">(9).AbstractBootstrap.handler é…ç½®æ—¥å¿—</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// é…ç½®bossHadnler
private volatile ChannelHandler handler;

public B handler(ChannelHandler handler) {
    // handler = io.netty.handler.logging.LoggingHandler
    this.handler = ObjectUtil.checkNotNull(handler, "handler");
    return self();
}
</code></pre></div></div>

<h3 id="10serverbootstrapchildhandler">(10).ServerBootstrap.childHandler</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// é…ç½®workHandler

private volatile ChannelHandler childHandler;

public ServerBootstrap childHandler(ChannelHandler childHandler) {
    // childHandler = io.netty.example.telnet.TelnetServerInitializer
    this.childHandler = ObjectUtil.checkNotNull(childHandler, "childHandler");
    return this;
}

</code></pre></div></div>

<h3 id="11abstractbootstrapbind">(11).AbstractBootstrap.bind</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public ChannelFuture bind(int inetPort) {
    // inetPort = 8023
    return bind(new InetSocketAddress(inetPort));
}

public ChannelFuture bind(SocketAddress localAddress) {
    // localAddress = 0.0.0.0/0.0.0.0:8023
    
    // éªŒè¯:channelFactory/groupéƒ½ä¸èƒ½ä¸ºç©º
    validate();
    
    // è°ƒç”¨doBind
    return doBind(ObjectUtil.checkNotNull(localAddress, "localAddress"));
}

private ChannelFuture doBind(final SocketAddress localAddress) {
    // 12. åˆå§‹åŒ–å¹¶æ³¨å†Œ
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();
    if (regFuture.cause() != null) {
            return regFuture;
    } //end if
    
    if (regFuture.isDone()) {
        // At this point we know that the registration was complete and successful.
        ChannelPromise promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    } else {
        // Registration future is almost always fulfilled already, but just in case it's not.
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                        // IllegalStateException once we try to access the EventLoop of the Channel.
                        promise.setFailure(cause);
                    } else {
                        // Registration was successful, so set the correct executor to use.
                        // See https://github.com/netty/netty/issues/2586
                        promise.registered();
                        doBind0(regFuture, channel, localAddress, promise);
                    }
                }
            }); //end addListener
            return promise;
    } //end else
}
</code></pre></div></div>

<h3 id="12abstractbootstrapinitandregister">(12).AbstractBootstrap.initAndRegister</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// åˆå§‹åŒ–:ChannelFuture
final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        // *****************************************************************
        // é€šè¿‡åå°„å·¥å‚åˆ›å»ºå‡º:io.netty.channel.socket.nio.NioServerSocketChannel
        // NioServerSocketChannelå¦èµ·ä¸€éè¿›è¡Œåˆ†æ
        // *****************************************************************
        channel = channelFactory.newChannel();
        // 13. è°ƒç”¨å­ç±»(ServerBootstrap),é…ç½®:NioServerSocketChannel
        init(channel);
    } catch (Throwable t) {
        if (channel != null) {
            // channel can be null if newChannel crashed (eg SocketException("too many open files"))
            channel.unsafe().closeForcibly();
            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    }
    
    // ****************************************************
    // ****************************************************
    // config().group() == NioEventLoopGroup
    // å¾€BossGroup(NioEventLoopGroup)ä¸­æ³¨å†Œ:NioServerSocketChannel
    // ****************************************************
    // ****************************************************
    ChannelFuture regFuture = config().group().register(channel);
    
    if (regFuture.cause() != null) {  // false
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }
    return regFuture;
} // end initAndRegister
</code></pre></div></div>

<h3 id="13serverbootstrapinit">(13).ServerBootstrap.init</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// å¯¹NioServerSocketChannelè¿›è¡Œç›¸å…³é…ç½®
void init(Channel channel) {
    // channel = NioServerSocketChannel
    setChannelOptions(channel, newOptionsArray(), logger);
    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));

    // DefaultChannelPipeline
    ChannelPipeline p = channel.pipeline();

    // io.netty.channel.nio.NioEventLoopGroup
    // è·å¾—workGroup
   final EventLoopGroup currentChildGroup = childGroup;
   // è·å¾—workgChild
   // io.netty.example.telnet.TelnetServerInitializer
   final ChannelHandler currentChildHandler = childHandler;
   
   // childé…ç½®é¡¹
   final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;
    synchronized (childOptions) {
        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);
    }
    
    // []
    final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);
    
    // **************************************************
    // åœ¨é»˜è®¤çš„DefaultChannelPipelineçš„åŸºç¡€ä¸Šæ·»åŠ ä¸€ä¸ª:io.netty.channel.ChannelHandler
    // **************************************************
    p.addLast(new ChannelInitializer&lt;Channel&gt;() {
        @Override
        public void initChannel(final Channel ch) {
            final ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }
            
            // ****************************************
            // æ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—é‡Œ
            // ****************************************
            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    pipeline.addLast(new ServerBootstrapAcceptor(
                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
            });
        }
    }); // end addLast
}
</code></pre></div></div>

<h3 id="14multithreadeventloopgroupnioeventloopgroupregister">(14).MultithreadEventLoopGroup(NioEventLoopGroup).register</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public ChannelFuture register(Channel channel) {
    // channel = NioServerSocketChannel
    // next() --&gt; io.netty.util.concurrent.DefaultEventExecutorChooserFactory$PowerOfTwoEventExecutorChooser
    // next() æ–¹æ³•ç›¸å½“äºä»å¤šä¸ªEventExecutor(NioEventLoop)ä¸­é€‰æ‹©ä¸€ä¸ª,ç±»ä¼¼äºç­–ç•¥æ¨¡å¼
    // next() è¿”å›çš„ç±»å‹ä¸º:EventExecutor(NioEventLoop)
    return next().register(channel);
}
</code></pre></div></div>

<h3 id="15singlethreadeventloopnioeventloopregister">(15).SingleThreadEventLoop(NioEventLoop).register</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public ChannelFuture register(Channel channel) {
    // channel = NioServerSocketChannel
    return register(new DefaultChannelPromise(channel, this));
}

public ChannelFuture register(final ChannelPromise promise) {
    ObjectUtil.checkNotNull(promise, "promise");
    // channel() == NioServerSocketChannel
    // ************************************************************************************************************
   // NioServerSocketChannelçš„æ„é€ å™¨åœ¨åˆå§‹åŒ–æ—¶,ä¼šè°ƒç”¨çˆ¶ç±»çš„æ„é€ å™¨:AbstractChannel
   // è€Œçˆ¶ç±»æ„é€ å™¨ä¼šè°ƒç”¨:AbstractNioMessageChannel.newUnsafe() æ„å»ºå‡ºä¸€ä¸ª:AbstractNioMessageChannel$NioMessageUnsafe
   // ************************************************************************************************************
   
    promise.channel().unsafe().register(this, promise);
    return promise;
}
</code></pre></div></div>

<h3 id="16abstractniomessagechannelniomessageunsaferegister">(16).AbstractNioMessageChannel.NioMessageUnsafe.register</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ********************************************************************************************
// AbstractNioMessageChannel.NioMessageUnsafe ç»§æ‰¿äº:AbstractChannel.AbstractUnsafe
// ********************************************************************************************

public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
    
    protected abstract class AbstractUnsafe implements Unsafe {
        
        public final void register(EventLoop eventLoop, final ChannelPromise promise) {
            // eventLoop = io.netty.channel.nio.NioEventLoop
            // promise = DefaultChannelPromise
            ObjectUtil.checkNotNull(eventLoop, "eventLoop");
            
            if (isRegistered()) { // false
                promise.setFailure(new IllegalStateException("registered to an event loop already"));
                return;
            }
            
            if (!isCompatible(eventLoop)) { // false
                promise.setFailure(
                        new IllegalStateException("incompatible event loop type: " + eventLoop.getClass().getName()));
                return;
            }

            // è¿™ä¸ªæ–¹æ³•åº”è¯¥åªå¯èƒ½è°ƒç”¨ä¸€æ¬¡
            // ç»™eventLoopèµ‹å€¼
            AbstractChannel.this.eventLoop = eventLoop;

            // åˆ¤æ–­:NioEventLoopä¸­çš„çº¿ç¨‹æ˜¯å¦ä¸ºå½“å‰çº¿ç¨‹
            // è¿™ä¸ªæ—¶å€™,NioEventLoopä¸­çš„threadçš„å±æ€§è¿˜ä¸ºç©ºä¸­.
            if (eventLoop.inEventLoop()) { // false
                register0(promise);
            } else {
                try {
                 // ***************************************************
                // è°ƒç”¨:SingleThreadEventExecutor(NioEventLoop).execute(....)
                // ***************************************************
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                //     
                } catch (Throwable t) {
                    logger.warn(
                            "Force-closing a channel whose registration task was not accepted by an event loop: {}",
                            AbstractChannel.this, t);
                    closeForcibly();
                    closeFuture.setClosed();
                    safeSetFailure(promise, t);
                }
            }// 
        } // end register
    }
}

</code></pre></div></div>
<h3 id="17singlethreadeventexecutornioeventloopexecute">(17).SingleThreadEventExecutor(NioEventLoop).execute</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void execute(Runnable task) {
    // task = io.netty.channel.AbstractChannel$AbstractUnsafe$1
    ObjectUtil.checkNotNull(task, "task");
    execute(task, !(task instanceof LazyRunnable) &amp;&amp; wakesUpForTask(task));
}
</code></pre></div></div>

<h3 id="18singlethreadeventexecutornioeventloopexecute">(18).SingleThreadEventExecutor(NioEventLoop).execute</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void execute(Runnable task, boolean immediate) {
    // task = io.netty.channel.AbstractChannel$AbstractUnsafe.register0
    // immediate = true
    // inEventLoop = false
    boolean inEventLoop = inEventLoop();
    // æ·»åŠ ä»»åŠ¡è¿›å…¥é˜Ÿåˆ—
    addTask(task);
    if (!inEventLoop) { //!(false)
        // 18.å¼€å¯çº¿ç¨‹
        startThread();
        
        if (isShutdown()) {
            boolean reject = false;
            try {
                if (removeTask(task)) {
                    reject = true;
                } // end if
            } catch (UnsupportedOperationException e) {
            }
            
            if (reject) {
                reject();
            } // end if
            
        } // end if
    } // end if

    if (!addTaskWakesUp &amp;&amp; immediate) {
        wakeup(inEventLoop);
    } // end if
}



protected void addTask(Runnable task) {
    ObjectUtil.checkNotNull(task, "task");
    if (!offerTask(task)) { // !(true)
        reject(task);
    }
} //end addTask


// çº¿ç¨‹çŠ¶æ€
volatile int state = ST_NOT_STARTED;
// ä»»åŠ¡é˜Ÿåˆ—
final Queue&lt;Runnable&gt; taskQueue;

final boolean offerTask(Runnable task) {
    // å¦‚æœçº¿ç¨‹çš„çŠ¶æ€æ˜¯å…³é—­,åˆ™æ‹’ç»,å¦åˆ™:æ·»åŠ åˆ°ä»»åŠ¡åˆ—è¡¨ä¸­
    if (isShutdown()) { // false
        reject();
    }
    // æ·»åŠ åˆ°ä»»åŠ¡é˜Ÿåˆ—é‡Œ
    return taskQueue.offer(task);
}
</code></pre></div></div>

<h3 id="19singlethreadeventexecutornioeventloopstartthread">(19).SingleThreadEventExecutor(NioEventLoop).startThread</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void startThread() {
    // ST_NOT_STARTED == æœªå¯åŠ¨
    // ST_STARTED == å¯åŠ¨
    // ST_SHUTTING_DOWN == å…³é—­å®Œæˆ
    // ST_SHUTDOWN == å…³é—­
    // ST_TERMINATED == ä¸­æ­¢
    // state åˆå§‹åŒ–æ—¶çš„é»˜è®¤å€¼æ˜¯:ST_NOT_STARTED
    if (state == ST_NOT_STARTED) { // true
        // çŠ¶æ€æ›´æ–°å™¨
        // æ¯”è¾ƒNioEventLoopçš„state
        // å¦‚æœstate = ST_NOT_STARTED åˆ™æ›´æ–°ä¸º:ST_STARTED
        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) { // true
            boolean success = false;
            try {
                // å¼€å§‹å¯åŠ¨çº¿ç¨‹.
                doStartThread();
                success = true;
            } finally {
                // å¦‚æœæ²¡æœ‰æˆåŠŸ,åˆ™é‡æ–°è®¾ç½®state == ST_NOT_STARTED(æœªå¯åŠ¨)
                if (!success) {
                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);
                }
            } // end finally
        } // end if
    }// end if
}
</code></pre></div></div>

<h3 id="20singlethreadeventexecutornioeventloopdostartthread">(20).SingleThreadEventExecutor(NioEventLoop).doStartThread</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void doStartThread() {
    assert thread == null;
    // ******************************************************************
    // å¦å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹å»åˆå§‹åŒ–Thread å¹¶è°ƒç”¨:SingleThreadEventExecutor.runæ–¹æ³•
    // ******************************************************************
    executor.execute(new Runnable() {
        @Override
        public void run() {
            // thread = Thread[nioEventLoopGroup-2-1,10,main]
            thread = Thread.currentThread();
            
            if (interrupted) { // false
                thread.interrupt();
            }

            boolean success = false;
            // æ›´æ–°æœ€åæ‰§è¡Œçº¿ç¨‹çš„æ—¶é—´
            updateLastExecutionTime();
            try {
                // *********************************************************
                // è°ƒç”¨:NioEventLoop.run()æ–¹æ³•
                // *********************************************************
                SingleThreadEventExecutor.this.run();
                success = true;
            } catch (Throwable t) {
                logger.warn("Unexpected exception from an event executor: ", t);
            } finally {
                for (;;) {
                    int oldState = state;
                    if (oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(
                            SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) {
                        break;
                    }
                }

                // Check if confirmShutdown() was called at the end of the loop.
                if (success &amp;&amp; gracefulShutdownStartTime == 0) {
                    if (logger.isErrorEnabled()) {
                        logger.error("Buggy " + EventExecutor.class.getSimpleName() + " implementation; " +
                                SingleThreadEventExecutor.class.getSimpleName() + ".confirmShutdown() must " +
                                "be called before run() implementation terminates.");
                    }
                }

                try {
                    // Run all remaining tasks and shutdown hooks. At this point the event loop
                    // is in ST_SHUTTING_DOWN state still accepting tasks which is needed for
                    // graceful shutdown with quietPeriod.
                    for (;;) {
                        if (confirmShutdown()) {
                            break;
                        }
                    }

                    // Now we want to make sure no more tasks can be added from this point. This is
                    // achieved by switching the state. Any new tasks beyond this point will be rejected.
                    for (;;) {
                        int oldState = state;
                        if (oldState &gt;= ST_SHUTDOWN || STATE_UPDATER.compareAndSet(
                                SingleThreadEventExecutor.this, oldState, ST_SHUTDOWN)) {
                            break;
                        }
                    }

                    // We have the final set of tasks in the queue now, no more can be added, run all remaining.
                    // No need to loop here, this is the final pass.
                    confirmShutdown();
                } finally {
                    try {
                        cleanup();
                    } finally {
                        // Lets remove all FastThreadLocals for the Thread as we are about to terminate and notify
                        // the future. The user may block on the future and once it unblocks the JVM may terminate
                        // and start unloading classes.
                        // See https://github.com/netty/netty/issues/6596.
                        FastThreadLocal.removeAll();

                        STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);
                        threadLock.countDown();
                        int numUserTasks = drainTasks();
                        if (numUserTasks &gt; 0 &amp;&amp; logger.isWarnEnabled()) {
                            logger.warn("An event executor terminated with " +
                                    "non-empty task queue (" + numUserTasks + ')');
                        }
                        terminationFuture.setSuccess(null);
                    }
                }
            }
        }
    });
} // end doStartThread

</code></pre></div></div>

<h3 id="21nioeventlooprun">(21).NioEventLoop.run</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected void run() {
    int selectCnt = 0;
    for (;;) {  // æ­»å¾ªç¯
        try {
            int strategy;
            try {
                // åˆ¤æ–­æ˜¯å¦æœ‰äº‹ä»¶æˆ–è€…é˜Ÿåˆ—æ˜¯å¦æœ‰æ•°æ®
                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                // strategy = 0
                // æ•´ä¸ªswitchéƒ½ä¸è¿›å…¥
                switch (strategy) { 
                case SelectStrategy.CONTINUE:
                    continue;

                case SelectStrategy.BUSY_WAIT:
                    // fall-through to SELECT since the busy-wait is not supported with NIO

                case SelectStrategy.SELECT:
                    long curDeadlineNanos = nextScheduledTaskDeadlineNanos();
                    if (curDeadlineNanos == -1L) {
                        curDeadlineNanos = NONE; // nothing on the calendar
                    }
                    nextWakeupNanos.set(curDeadlineNanos);
                    try {
                        if (!hasTasks()) {
                            strategy = select(curDeadlineNanos);
                        }
                    } finally {
                        // This update is just to help block unnecessary selector wakeups
                        // so use of lazySet is ok (no race condition)
                        nextWakeupNanos.lazySet(AWAKE);
                    }
                    // fall through
                default:
                }
            } catch (IOException e) {
                // If we receive an IOException here its because the Selector is messed up. Let's rebuild
                // the selector and retry. https://github.com/netty/netty/issues/8566
                rebuildSelector0();
                selectCnt = 0;
                handleLoopException(e);
                continue;
            }
            
            // ç»Ÿè®¡å€¼è¿›è¡Œè‡ªå¢
            selectCnt++;
            cancelledKeys = 0;
            needsToSelectAgain = false;
            final int ioRatio = this.ioRatio;
            boolean ranTasks;
            // ioRatio = 50 
            if (ioRatio == 100) { // false
                try {
                    if (strategy &gt; 0) {
                        processSelectedKeys();
                    }
                } finally {
                    // Ensure we always run tasks.
                    ranTasks = runAllTasks();
                }
            } else if (strategy &gt; 0) { // false(strategy == 0)
                final long ioStartTime = System.nanoTime();
                try {
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    final long ioTime = System.nanoTime() - ioStartTime;
                    ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                }
            } else {
                // ************************************************
                // è¿è¡Œæ‰€æœ‰çš„ä»»åŠ¡
                // ************************************************
                ranTasks = runAllTasks(0); // This will run the minimum number of tasks
            }

            if (ranTasks || strategy &gt; 0) {
                if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;&amp; logger.isDebugEnabled()) {
                    logger.debug("Selector.select() returned prematurely {} times in a row for Selector {}.",
                            selectCnt - 1, selector);
                }
                selectCnt = 0;
            } else if (unexpectedSelectorWakeup(selectCnt)) { // Unexpected wakeup (unusual case)
                selectCnt = 0;
            }
        } catch (CancelledKeyException e) {
            // Harmless exception - log anyway
            if (logger.isDebugEnabled()) {
                logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector {} - JDK bug?",
                        selector, e);
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
        // Always handle shutdown even if the loop processing threw an exception.
        try {
            if (isShuttingDown()) {
                closeAll();
                if (confirmShutdown()) {
                    return;
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
    }
} // end run
</code></pre></div></div>

<h3 id="22singlethreadeventexecutornioeventlooprunalltasks">(22).SingleThreadEventExecutor(NioEventLoop).runAllTasks</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected boolean runAllTasks(long timeoutNanos) {
    // timeoutNanos == 0
    fetchFromScheduledTaskQueue();
    // ä»é˜Ÿåˆ—é‡Œæ‹‰å–ä»»åŠ¡
    Runnable task = pollTask();
    
    // å¦‚æœä»»åŠ¡ä¸ä¸ºç©º,åˆ™è¿”å›
    if (task == null) { // false
        afterRunningAllTasks();
        return false;
    }

    // deadline = 0
    final long deadline = timeoutNanos &gt; 0 ? ScheduledFutureTask.nanoTime() + timeoutNanos : 0;
    long runTasks = 0;
    long lastExecutionTime;
    
    
    for (;;) {
        // ********************************************************
        // æ­¤æ—¶ä¼šå›è°ƒ:AbstractChannel$AbstractUnsafe.register0()
        //          ServerBootstrap$init
        // ********************************************************
        safeExecute(task);

        runTasks ++;
        
        if ((runTasks &amp; 0x3F) == 0) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            if (lastExecutionTime &gt;= deadline) {
                break;
            }
        }

        // å¦‚æœé˜Ÿåˆ—é‡Œä¸€ä¸ªæœ‰å†…å®¹,é‚£è¿™ä¸ªrunæ˜¯ä¸æ˜¯ä»£è¡¨ä¸ä¼šé€€å‡º
        // å†ä»é˜Ÿåˆ—é‡Œå–å‡ºä¸€ä¸ªä»»åŠ¡å‡ºæ¥
        // ServerBootstrap$init
        // ServerBootstrapAcceptor
        task = pollTask();
        if (task == null) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            break;
        }
    }

    afterRunningAllTasks();
    this.lastExecutionTime = lastExecutionTime;
    return true;
} // end runAllTasks


private boolean fetchFromScheduledTaskQueue() {
    // scheduledTaskQueue = null
    if (scheduledTaskQueue == null || scheduledTaskQueue.isEmpty()) {
        // ç›´æ¥è¿”å›äº†
        return true;
    }
    long nanoTime = AbstractScheduledEventExecutor.nanoTime();
    for (;;) {
        Runnable scheduledTask = pollScheduledTask(nanoTime);
        if (scheduledTask == null) {
            return true;
        }
        if (!taskQueue.offer(scheduledTask)) {
            // No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again.
            scheduledTaskQueue.add((ScheduledFutureTask&lt;?&gt;) scheduledTask);
            return false;
        }
    }
} // end fetchFromScheduledTaskQueue


protected Runnable pollTask() {
    assert inEventLoop();
    return pollTaskFrom(taskQueue);
}

protected static Runnable pollTaskFrom(Queue&lt;Runnable&gt; taskQueue) {
    for (;;) {
        // ä»é˜Ÿåˆ—é‡Œæ‹‰å–å‡ºæ•°
        Runnable task = taskQueue.poll();
        // å¦‚æœä»»åŠ¡ä¸æ˜¯å”¤é†’ä»»åŠ¡,åˆ™è¿”å›ä»»åŠ¡
        if (task != WAKEUP_TASK) {
            return task;
        }
    }
}

</code></pre></div></div>

<h3 id="23abstractchannelnioserversocketchannelabstractunsaferegister0">(23).AbstractChannel(NioServerSocketChannel)$AbstractUnsafe.register0</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void register0(ChannelPromise promise) {
    try {
        
        if (!promise.setUncancellable() || !ensureOpen(promise)) { // false
            return;
        }
        
        // firstRegistration
        boolean firstRegistration = neverRegistered;
       //  **********************************************************************
       // AbstractNioChannel$AbstractNioUnsafe.doRegister()
       // è°ƒç”¨å­ç±»çš„doRegister
       // æŠŠChannelä¸Selectorè¿›è¡Œç»‘å®š
       //  **********************************************************************
       doRegister();
       neverRegistered = false;
       registered = true;
       
       // pipeline = io.netty.channel.DefaultChannelPipeline 
       // **********************************************************
       // 24.è°ƒç”¨æ‰€æœ‰çš„:ChanelHandler.handlerAdded
       // **********************************************************
       pipeline.invokeHandlerAddedIfNeeded();


       safeSetSuccess(promise);
       
       // ****************************************
       // 28. DefaultChannelPipeline.fireChannelRegistered
       // è°ƒç”¨æ‰€æœ‰ChannelHandlerContextå¯¹åº”handler.channelRegistered
       // ****************************************
       pipeline.fireChannelRegistered();
       
       if (isActive()) { // false
           if (firstRegistration) {
                pipeline.fireChannelActive();
           } else if (config().isAutoRead()) {
                // This channel was registered before and autoRead() is set. This means we need to begin read
                // again so that we process inbound data.
                //
                // See https://github.com/netty/netty/issues/4805
                beginRead();
           } // end else if
       } // end if
    } catch (Throwable t) {
        // Close the channel directly to avoid FD leak.
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    }
} // end register0

</code></pre></div></div>

<h3 id="24abstractniochannelnioserversocketchannelabstractniounsafedoregister">(24).AbstractNioChannel(NioServerSocketChannel)$AbstractNioUnsafe.doRegister()</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected void doRegister() throws Exception {
    boolean selected = false;
    for (;;) {
        try {
            // **************************************************
            // è°ƒç”¨JDKåŸç”Ÿçš„æ³¨å†Œäº‹ä»¶,å°†:Channelä¸Selectorè¿›è¡Œç»‘å®š
            // eventLoop().unwrappedSelector() = sun.nio.ch.KQueueSelectorImpl
            // javaChannel() = sun.nio.ch.ServerSocketChannelImpl
            // **************************************************
            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
            return;
        } catch (CancelledKeyException e) {
            if (!selected) {
                // Force the Selector to select now as the "canceled" SelectionKey may still be
                // cached and not removed because no Select.select(..) operation was called yet.
                eventLoop().selectNow();
                selected = true;
            } else {
                // We forced a select operation on the selector before but the SelectionKey is still cached
                // for whatever reason. JDK bug ?
                throw e;
            }
        }
    } // end for
} // end doRegister

</code></pre></div></div>

<h3 id="25defaultchannelpipelineinvokehandleraddedifneeded">(25).DefaultChannelPipeline.invokeHandlerAddedIfNeeded</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final void invokeHandlerAddedIfNeeded() {
    assert channel.eventLoop().inEventLoop();
    // ç¬¬ä¸€æ¬¡æ³¨å†Œ
    if (firstRegistration) { // true
        firstRegistration = false;
        // 
        callHandlerAddedForAllHandlers();
    }
} // end invokeHandlerAddedIfNeeded


private void callHandlerAddedForAllHandlers() {

    final PendingHandlerCallback pendingHandlerCallbackHead;
    synchronized (this) {
        assert !registered;
        registered = true;
        // 1. è·å¾—å®ä¾‹å˜é‡
        // this.pendingHandlerCallbackHead = io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask
        // pendingHandlerCallbackHead = io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask
        pendingHandlerCallbackHead = this.pendingHandlerCallbackHead;
        
        // 2. æ¸…ç©ºå®ä¾‹å˜é‡çš„å€¼.
        this.pendingHandlerCallbackHead = null;
    }
    
    // task = io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask
    PendingHandlerCallback task = pendingHandlerCallbackHead;
    while (task != null) {
        // æ‰§è¡Œexecute()æ–¹æ³•
        task.execute();
        task = task.next;
    }
} // end callHandlerAddedForAllHandlers
</code></pre></div></div>

<h3 id="26pendinghandleraddedtaskexecute">(26).PendingHandlerAddedTask.execute</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void execute() {
    // ä»ä¸Šä¸‹æ–‡ä¸­è·å¾—:executeor
    // executor = io.netty.channel.nio.NioEventLoop
    EventExecutor executor = ctx.executor();
    
    if (executor.inEventLoop()) { // true
        // *******************************************
        // è°ƒç”¨handlerAddæ–¹æ³•
        // *******************************************
        callHandlerAdded0(ctx);
    } else {
        try {
            executor.execute(this);
        } catch (RejectedExecutionException e) {
            if (logger.isWarnEnabled()) {
                logger.warn(
                        "Can't invoke handlerAdded() as the EventExecutor {} rejected it, removing handler {}.",
                        executor, ctx.name(), e);
            }
            atomicRemoveFromHandlerList(ctx);
            ctx.setRemoved();
        }
    }
} // end execute
</code></pre></div></div>
<h3 id="27defaultchannelpipelinecallhandleradded0">(27).DefaultChannelPipeline.callHandlerAdded0</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) {
    try {
        // è°ƒç”¨handlerAddedæ–¹æ³•
        ctx.callHandlerAdded();
    } catch (Throwable t) {
        boolean removed = false;
        try {
            atomicRemoveFromHandlerList(ctx);
            ctx.callHandlerRemoved();
            removed = true;
        } catch (Throwable t2) {
            if (logger.isWarnEnabled()) {
                logger.warn("Failed to remove a handler: " + ctx.name(), t2);
            }
        }
    
        if (removed) {
            fireExceptionCaught(new ChannelPipelineException(
                    ctx.handler().getClass().getName() +
                    ".handlerAdded() has thrown an exception; removed.", t));
        } else {
            fireExceptionCaught(new ChannelPipelineException(
                    ctx.handler().getClass().getName() +
                    ".handlerAdded() has thrown an exception; also failed to remove.", t));
        }
    } // end catch
} // end callHandlerAdded0

</code></pre></div></div>

<h3 id="28defaultchannelhandlercontextcallhandleradded">(28).DefaultChannelHandlerContext.callHandlerAdded</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>final void callHandlerAdded() throws Exception {
    if (setAddComplete()) { //true
        //  handlerä¸ºä¸šåŠ¡çš„ChannelHandler
        // io.netty.bootstrap.ServerBootstrap$1
        handler().handlerAdded(this);
    }
}

final boolean setAddComplete() {
    for (;;) {
        int oldState = handlerState;
        if (oldState == REMOVE_COMPLETE) {
            return false;
        }
        // å¾ªç¯ä¿®æ”¹çŠ¶æ€ä¸º:ADD_COMPLETE
        if (HANDLER_STATE_UPDATER.compareAndSet(this, oldState, ADD_COMPLETE)) {
            return true;
        }
    } // end 
}

</code></pre></div></div>
<h3 id="29defaultchannelpipelinefirechannelregistered">(29).DefaultChannelPipeline.fireChannelRegistered</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final ChannelPipeline fireChannelRegistered() {
    AbstractChannelHandlerContext.invokeChannelRegistered(head);
    return this;
}
</code></pre></div></div>

<h3 id="30abstractchannelhandlercontextinvokechannelregistered">(30).AbstractChannelHandlerContext.invokeChannelRegistered</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>static void invokeChannelRegistered(final AbstractChannelHandlerContext next) {
    // next = DefaultChannelPipeline$HeadContext#0
    // executor = io.netty.channel.nio.NioEventLoop
    EventExecutor executor = next.executor();
    if (executor.inEventLoop()) {// true
        // 
        next.invokeChannelRegistered();
    } else {
        executor.execute(new Runnable() {
            @Override
            public void run() {
                next.invokeChannelRegistered();
            }
        });
    }
} // end invokeChannelRegistered


private void invokeChannelRegistered() {
    if (invokeHandler()) { // true
        try {
            // è°ƒç”¨:channelRegistered(ChannelHandlerContext)æ–¹æ³•
            ((ChannelInboundHandler) handler()).channelRegistered(this);
        } catch (Throwable t) {
            invokeExceptionCaught(t);
        }
    } else {
        fireChannelRegistered();
    }
} // end

</code></pre></div></div>
<h3 id="31-æ€»ç»“">(31). æ€»ç»“</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. åˆ›å»ºNioEventLoopGroup,å†…éƒ¨æŒæœ‰å¤šä¸ª:NioEventLoop/Selector.
2. åˆ›å»ºNioServerSocketChannel(å†…éƒ¨æŒæœ‰:ChannelPipeline)
3. è°ƒç”¨:NioEventLoop.register(NioServerSocketChannel)
4. NioEventLoopå§”æ‰˜ç»™(NioServerSocketChannel)
    AbstractNioMessageChannel$NioMessageUnsafe.register
5. AbstractNioMessageChannel$NioMessageUnsafe.register
    5.1 åˆ›å»ºRunnable -&gt; AbstractChannel$AbstractUnsafe.register0
    5.2 å§”æ‰˜ç»™:NioEventLoop.execute(Runnable)å¼‚æ­¥æäº¤ä»»åŠ¡.
6. NioEventLoop.execute
    6.1 æ·»åŠ Runnableåˆ°NioEventLoop.taskQueueä¸­
    6.2 å¯åŠ¨çº¿ç¨‹(SingleThreadEventExecutor.run())
7. NioEventLoop.run
    7.1 å¯¹äº‹ä»¶è¿›è¡Œå¤„ç†,ä½†æ²¡æœ‰äº‹ä»¶æ—¶,æ‰§è¡Œæ‰€æœ‰çš„ä»»åŠ¡	
        (SingleThreadEventExecutor.runAllTasks)
    7.2 SingleThreadEventExecutor.runAllTasksä¼šä»SingleThreadEventExecutor.taskQueueä¸­æ‹‰å–ä»»åŠ¡,å¹¶è¿è¡Œ.
8. SingleThreadEventExecutor.taskQueueä»»åŠ¡æœ‰å¦‚ä¸‹å‡ ä¸ª
    8.1 AbstractChannel$AbstractUnsafe.register0
    8.2 ServerBootstrap.init() æ–¹æ³•å†…éƒ¨åˆ›å»ºRunnable:Runnable(ServerBootstrapAcceptor)
</code></pre></div></div>
:ET