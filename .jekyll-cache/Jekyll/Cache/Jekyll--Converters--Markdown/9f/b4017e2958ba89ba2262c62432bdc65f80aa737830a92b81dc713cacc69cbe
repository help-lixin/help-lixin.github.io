I"€Q<h3 id="1bossgroupnioeventloopåˆå§‹åŒ–å®Œæˆäº†æ˜¯æ€ä¹ˆæ¥å—è¯·æ±‚acceptäº‹ä»¶å¹¶æŠŠè¯·æ±‚åˆ†å‘ç»™workgroupnioeventloopçš„å‘¢">(1).BossGroup(NioEventLoop)åˆå§‹åŒ–å®Œæˆäº†,æ˜¯æ€ä¹ˆæ¥å—è¯·æ±‚(ACCEPTäº‹ä»¶),å¹¶æŠŠè¯·æ±‚åˆ†å‘ç»™:WorkGroup(NioEventLoop)çš„å‘¢?</h3>
<blockquote>
  <p>ç­”æ¡ˆåœ¨:<font color="red">NioEventLoop.run()</font>æ–¹æ³•é‡Œ.</p>
</blockquote>

<h3 id="2nioeventlooprun">(2).NioEventLoop.run</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class NioEventLoop extends SingleThreadEventLoop {
    protected void run() {
        int selectCnt = 0;
        for (;;) {
            
            try {
                int strategy;
                try {
                    // strategy = -1;
                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                    switch (strategy) {
                    case SelectStrategy.CONTINUE:
                        continue;
                    case SelectStrategy.BUSY_WAIT:
                    // ******************************************
                    // äº§ç”Ÿè½®è¯¢
                    // ******************************************
                    case SelectStrategy.SELECT:
                        // curDeadlineNanos = -1
                        long curDeadlineNanos = nextScheduledTaskDeadlineNanos();
                        if (curDeadlineNanos == -1L) { // true
                            //  NONE = 9223372036854775807
                            curDeadlineNanos = NONE; // nothing on the calendar
                        }
                        // 
                        nextWakeupNanos.set(curDeadlineNanos);
                        try {
                            if (!hasTasks()) { //true
                                // **************************************
                                // strategy = -1
                                // 3. è°ƒç”¨Selector.select() é˜»å¡ç­‰å¾…å®¢æˆ·ç«¯çš„è¿æ¥
                                // **************************************
                                strategy = select(curDeadlineNanos);
                            }
                        } finally {
                            nextWakeupNanos.lazySet(AWAKE);
                        }
                        // fall through
                    default:
                    }
                } catch (IOException e) {
                    rebuildSelector0();
                    selectCnt = 0;
                    handleLoopException(e);
                    continue;
                } //end catch

                selectCnt++;
                cancelledKeys = 0;
                needsToSelectAgain = false;
                final int ioRatio = this.ioRatio;
                boolean ranTasks;
                
                // ioRatio = 50
                if (ioRatio == 100) {
                    try {
                        if (strategy &gt; 0) {
                            processSelectedKeys();
                        }
                    } finally {
                        // Ensure we always run tasks.
                        ranTasks = runAllTasks();
                    }
                } else if (strategy &gt; 0) {
                    final long ioStartTime = System.nanoTime();
                    try {
                        // ******************************************
                        // 4. å¤„ç†Selectäº‹ä»¶
                        // ******************************************
                        processSelectedKeys();
                    } finally {
                        // Ensure we always run tasks.
                        // ioTime = 650326301514
                        final long ioTime = System.nanoTime() - ioStartTime;
                        // **************************************************
                        // 9. è¿è¡Œæ‰€æœ‰çš„ä»»åŠ¡(SingleThreadEventExecutor.runAllTasks)
                        // **************************************************
                        ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                    }
                } else {
                    ranTasks = runAllTasks(0); // This will run the minimum number of tasks
                }

                if (ranTasks || strategy &gt; 0) {
                    if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;&amp; logger.isDebugEnabled()) {
                        logger.debug("Selector.select() returned prematurely {} times in a row for Selector {}.",
                                selectCnt - 1, selector);
                    }
                    selectCnt = 0;
                } else if (unexpectedSelectorWakeup(selectCnt)) { // Unexpected wakeup (unusual case)
                    selectCnt = 0;
                }
            } catch (CancelledKeyException e) {
                // Harmless exception - log anyway
                if (logger.isDebugEnabled()) {
                    logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector {} - JDK bug?",
                            selector, e);
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
            
            // Always handle shutdown even if the loop processing threw an exception.
            try {
                if (isShuttingDown()) {
                    closeAll();
                    if (confirmShutdown()) {
                        return;
                    }
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }// end catch
            
        } // end for
    } // end run
}
</code></pre></div></div>
<h3 id="3nioeventloopselect">(3).NioEventLoop.select</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private int select(long deadlineNanos) throws IOException {
    // deadlineNanos = 9223372036854775807
    if (deadlineNanos == NONE) { // true
        // selector  = io.netty.channel.nio.SelectedSelectionKeySetSelector
        // ************************************************
        //  select()ä¸ºé˜»å¡æ–¹æ³•
        //  é˜»å¡ç­‰å¾…å®¢æˆ·ç«¯çš„è¿æ¥.ä¸€æ—¦å‘ç°æœ‰è¿æ¥è¿‡æ¥,å°±å°†äº‹ä»¶å­˜å‚¨åˆ°:
        //  SelectedSelectionKeySeté‡Œé¢
        // ************************************************
        return selector.select();
    }
    // Timeout will only be 0 if deadline is within 5 microsecs
    long timeoutMillis = deadlineToDelayNanos(deadlineNanos + 995000L) / 1000000L;
    return timeoutMillis &lt;= 0 ? selector.selectNow() : selector.select(timeoutMillis);
}
</code></pre></div></div>
<h3 id="4nioeventloopprocessselectedkeys">(4).NioEventLoop.processSelectedKeys</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void processSelectedKeys() {
    // selectedKeys = sun.nio.ch.SelectionKeyImpl
    if (selectedKeys != null) {
        processSelectedKeysOptimized();
    } else {
        processSelectedKeysPlain(selector.selectedKeys());
    }
}
</code></pre></div></div>
<h3 id="5-nioeventloopprocessselectedkeysoptimized">(5). NioEventLoop.processSelectedKeysOptimized</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void processSelectedKeysOptimized() {
    // *************************************************
    // NioEventLoop.select() æ–¹æ³•ä¼šå°†ç”¨æˆ·è§¦å‘çš„äº‹ä»¶æ·»åŠ åˆ°:
    // selectedKeysä¸­
    // *************************************************
    // selectedKeys.size = 1 æ­¤æ—¶åªæœ‰ä¸€ä¸ªclientè¿æ¥ä¸Šæ¥äº†
    for (int i = 0; i &lt; selectedKeys.size; ++i) {
        // k = sun.nio.ch.SelectionKeyImpl
        // è·å¾—å¯¹åº”ä¸‹æ ‡çš„SelectionKey
        final SelectionKey k = selectedKeys.keys[i];
        // ç«‹å³å°†å¯¹åº”çš„keyè®¾ç½®ä¸ºç©º
        selectedKeys.keys[i] = null;
        
        // a = NioServerSocketChannel
        final Object a = k.attachment();
        
        if (a instanceof AbstractNioChannel) { // true
            processSelectedKey(k, (AbstractNioChannel) a);
        } else {
            @SuppressWarnings("unchecked")
            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;
            processSelectedKey(k, task);
        }
    
        if (needsToSelectAgain) { // false
            // null out entries in the array to allow to have it GC'ed once the Channel close
            // See https://github.com/netty/netty/issues/2363
            selectedKeys.reset(i + 1);
    
            selectAgain();
            i = -1;
        }
    }
}
</code></pre></div></div>
<h3 id="6nioeventloopprocessselectedkey">(6).NioEventLoop.processSelectedKey</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    //  k = sun.nio.ch.SelectionKeyImpl
    // ch = NioServerSocketChannel 
    
    // è·å¾—NioServerSocketChannelå†…éƒ¨çš„Unsafeå¯¹è±¡
    // unsafe = AbstractNioMessageChannel$NioMessageUnsafe
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();

    if (!k.isValid()) { // false
        final EventLoop eventLoop;
        try {
            eventLoop = ch.eventLoop();
        } catch (Throwable ignored) {
            // If the channel implementation throws an exception because there is no event loop, we ignore this
            // because we are only trying to determine if ch is registered to this event loop and thus has authority
            // to close ch.
            return;
        }
        // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
        // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
        // still healthy and should not be closed.
        // See https://github.com/netty/netty/issues/5125
        if (eventLoop == this) {
            // close the channel if the key is not valid anymore
            unsafe.close(unsafe.voidPromise());
        }
        return;
    }// end if
    
    try {
        // readyOps = 16
        int readyOps = k.readyOps();
        // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
        // the NIO JDK channel implementation may throw a NotYetConnectedException.
        if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) { // false
            // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
            // See https://github.com/netty/netty/issues/924
            int ops = k.interestOps();
            ops &amp;= ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);
    
            unsafe.finishConnect();
        }
    
        // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
        if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) { // false
            // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
            ch.unsafe().forceFlush();
        }
    
        // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
        // to a spin loop
        // true
        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            // *****************************************************
            // 6. AbstractNioMessageChannel.NioMessageUnsafe.read()
            // *****************************************************
            unsafe.read();
        }
    } catch (CancelledKeyException ignored) {
        unsafe.close(unsafe.voidPromise());
    }
}
</code></pre></div></div>
<h3 id="7abstractniomessagechannelniomessageunsaferead">(7).AbstractNioMessageChannel.NioMessageUnsafe.read</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void read() {
    assert eventLoop().inEventLoop();
    // config = NioServerSocketChannel$NioServerSocketChannelConfig
    final ChannelConfig config = config();
    // ä¸€ä¸ªæ—¥å¿—ChannelHandler å’Œ ServerBootstrap$ServerBootstrapAcceptor
    // pipeline = DefaultChannelPipeline{(LoggingHandler#0 = io.netty.handler.logging.LoggingHandler), (ServerBootstrap$ServerBootstrapAcceptor#0 = io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor)}
    final ChannelPipeline pipeline = pipeline();
    
    // allocHandle = io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl
    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
    allocHandle.reset(config);
    
        
    boolean closed = false;
    Throwable exception = null;
    try {
        try {
            do {
                // è°ƒç”¨:NioServerSocketChannel.doReadMessages
                // è¯»å–æ¶ˆæ¯
                int localRead = doReadMessages(readBuf);
                
                if (localRead == 0) { // false
                    break;
                }
                
                if (localRead &lt; 0) { // false
                    closed = true;
                    break;
                }
                
                
                // allocHandler = io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl
                allocHandle.incMessagesRead(localRead);
            } while (allocHandle.continueReading()); // end do while
        } catch (Throwable t) {
            exception = t;
        } // end catch

        
        int size = readBuf.size();
        for (int i = 0; i &lt; size; i ++) {
            readPending = false;
            // ******************************************************
            // readBuf.get(i) = NioSocketChannel
            // è°ƒç”¨BoosGroupé‡Œé…ç½®çš„æ‰€æœ‰handler.fireChannelRead
            // ä¼ é€’çš„NioSocketChannelæ˜¯åˆšæ‰:doReadMessages newå‡ºæ¥çš„
            // ******************************************************
            // 8.ServerBootstrap$ServerBootstrapAcceptor.channelRead()
            pipeline.fireChannelRead(readBuf.get(i));
        } // end for
        
        // æ¸…é™¤é›†åˆä¸­çš„æ•°æ®
        readBuf.clear();
        // æ ‡è®°è¯»å–å®Œæˆ
        allocHandle.readComplete();
        
        // ***************************************************
        // è°ƒç”¨pipelineä¸Šæ‰€æœ‰çš„ChannelHandler.channelReadComplete(ctx) æ–¹æ³•
        // ***************************************************
        pipeline.fireChannelReadComplete();
    
        if (exception != null) { // false
            closed = closeOnReadError(exception);
            pipeline.fireExceptionCaught(exception);
        }// end if
    
        if (closed) { // false
            inputShutdown = true;
            if (isOpen()) {
                close(voidPromise());
            } // end if
        }// end if
    } finally {
        // Check if there is a readPending which was not processed yet.
        // This could be for two reasons:
        // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
        // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
        //
        // See https://github.com/netty/netty/issues/2254

        if (!readPending &amp;&amp; !config.isAutoRead()) { // false
            removeReadOp();
        }
    } // end finally
}// end read
</code></pre></div></div>
<h3 id="8nioserversocketchanneldoreadmessages">(8).NioServerSocketChannel.doReadMessages</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected int doReadMessages(List&lt;Object&gt; buf) throws Exception {
    // buf=[]
    
    // **************************************************************
    // javaChannel = sun.nio.ch.ServerSocketChannelImpl
    // è°ƒç”¨:ServerSocketChannel.accept()æ–¹æ³•
    // è¿”å›ä¸€ä¸ª:java.nio.channels.SocketChannelå¯¹è±¡
    // **************************************************************
    java.nio.channels.SocketChannel ch = SocketUtils.accept(javaChannel());
    
    try {
        if (ch != null) {
            // åˆ›å»ºä¸€ä¸ª:io.netty.channel.socket.nio.NioSocketChannel
            // NioSocketChannel å†…éƒ¨æŒ
            // Channel = NioServerSocketChannel
            // SocketChannel = SocketChannel
            // æ·»åŠ åˆ°bufä¸­
            buf.add(new NioSocketChannel(this, ch));
            return 1;
        }
    } catch (Throwable t) {
        logger.warn("Failed to create a new channel from an accepted socket.", t); 
        try {
            ch.close();
        } catch (Throwable t2) {
            logger.warn("Failed to close a socket.", t2);
        }
    }    
    return 0;
}
</code></pre></div></div>
<h3 id="9serverbootstrapserverbootstrapacceptorchannelread">(9).ServerBootstrap$ServerBootstrapAcceptor.channelRead</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private final EventLoopGroup childGroup;
private final ChannelHandler childHandler;
private final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;
private final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;
private final Runnable enableAutoReadTask;

public void channelRead(ChannelHandlerContext ctx, Object msg) {
    // msg = NioSocketChannel
    // ctx = DefaultChannelHandlerContext
    final Channel child = (Channel) msg;
    
    // ä¸ºWorkGroupé…ç½®ç®¡é“ä¿¡æ¯
    child.pipeline().addLast(childHandler);
    // ä¸ºWorkGroupé…ç½®options
    setChannelOptions(child, childOptions, logger);
    // ä¸ºWorkGroupé…ç½®atrributes
    setAttributes(child, childAttrs);
    
    try {
        // å‘WorkGroup(EventLoopGroup[EventLoop])æ³¨å†ŒChannel
        childGroup.register(child).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    forceClose(child, future.cause());
                }
            }
        });
    } catch (Throwable t) {
        forceClose(child, t);
    }
} // end channelRead
</code></pre></div></div>
<h3 id="10nioeventlooprunalltasks">(10).NioEventLoop.runAllTasks</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected boolean runAllTasks(long timeoutNanos) {
    // timeoutNanos = 650326301514
    
    fetchFromScheduledTaskQueue();
    // æ‹‰å–ä»»åŠ¡
    Runnable task = pollTask();
    if (task == null) { // true
        afterRunningAllTasks();
        return false;
    }
    
    final long deadline = timeoutNanos &gt; 0 ? ScheduledFutureTask.nanoTime() + timeoutNanos : 0;
    long runTasks = 0;
    long lastExecutionTime;
    for (;;) {
        safeExecute(task);
    
        runTasks ++;
    
        // Check timeout every 64 tasks because nanoTime() is relatively expensive.
        // XXX: Hard-coded value - will make it configurable if it is really a problem.
        if ((runTasks &amp; 0x3F) == 0) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            if (lastExecutionTime &gt;= deadline) {
                break;
            }
        }
    
        task = pollTask();
        if (task == null) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            break;
        }
    }
    
    afterRunningAllTasks();
    this.lastExecutionTime = lastExecutionTime;
    return true;
}
</code></pre></div></div>
<h3 id="11acceptè¿‡ç¨‹å›¾è§£">(11).ACCEPTè¿‡ç¨‹å›¾è§£</h3>
<p><img src="/assets/netty/imgs/ServerSocketChannel-ACCEPT-EVENT.png" alt="&quot;ACCEPTè¿‡ç¨‹å›¾è§£&quot;" /></p>

<h3 id="12æ€»ç»“">(12).æ€»ç»“</h3>
<ol>
  <li>NioEventLoop.runæ–¹æ³•ä¼šä¸åœçš„è½®è¯¢.å½“è¿”å›çš„ç­–ç•¥ä¸º:SelectStrategy.SELECT</li>
  <li>è°ƒç”¨:SelectedSelectionKeySetSelector.select()æ–¹æ³•,ä¼šé˜»å¡æ–¹æ³•ç»§ç»­å¾€ä¸‹æ‰§è¡Œ,ç›´åˆ°æœ‰äº‹ä»¶è¿›å…¥.å¹¶æŠŠäº‹ä»¶å­˜å‚¨åˆ°:SelectedSelectionKeySeté›†åˆä¸­(ä¿®æ”¹Selectorçš„äº‹ä»¶å­˜å‚¨å¯¹è±¡).</li>
  <li>éå†é›†åˆ(SelectedSelectionKeySet)ä¸­æ‰€æœ‰çš„äº‹ä»¶(SelectionKey.OP_ACCEPT)</li>
  <li>è°ƒç”¨:AbstractNioMessageChannel.NioMessageUnsafe.readå¤„ç†ACCEPT/READäº‹ä»¶</li>
  <li>è°ƒç”¨:NioServerSocketChannel.doReadMessagesæ–¹æ³•,ä¼šå§”æ‰˜ç»™:ServerSocketChannel.accept,è¿”å›ä¸€ä¸ªSocketChannel.</li>
  <li>è°ƒç”¨:DefaultChannelPipeline.fireChannelRead,é€šçŸ¥æ‰€æœ‰ChannelHandler.channelReadæ–¹æ³•(ServerBootstrap.ServerBootstrapAcceptor.channelRead)
 6.1 ä¸ºWorkGroup(EventLoop)æ·»åŠ ChannelHandler
 6.2 ä¸ºWorkGroup(EventLoop)æ³¨å†ŒSocketChannel(å­Channel)</li>
  <li>è°ƒç”¨:DefaultChannelPipeline.fireChannelReadComplete.é€šçŸ¥æ‰€æœ‰ChannelHandler.channelReadCompleteæ–¹æ³•</li>
</ol>
:ET