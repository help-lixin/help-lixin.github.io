I"›/<h3 id="1nettyåˆæ˜¯å¦‚ä½•å¤„ç†è¯»å†™è¯·æ±‚çš„å‘¢">(1).Nettyåˆæ˜¯å¦‚ä½•å¤„ç†è¯»å†™è¯·æ±‚çš„å‘¢?</h3>
<blockquote>
  <p>ä»£ç çš„å…¥å£åœ¨:ServerBootstrap$ServerBootstrapAcceptor.channelReadå¤„.</p>
</blockquote>

<h3 id="2serverbootstrapserverbootstrapacceptorchannelread">(2).ServerBootstrap$ServerBootstrapAcceptor.channelRead</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void channelRead(ChannelHandlerContext ctx, Object msg) {
    final Channel child = (Channel) msg;
    
    // ****************************************************
    // æ·»åŠ childHandler
    // ****************************************************
    child.pipeline().addLast(childHandler);
    
    setChannelOptions(child, childOptions, logger);
    setAttributes(child, childAttrs);
    
    try {
        // ****************************************************
        // ****************************************************
        // ----------------------é‡ç‚¹å°±åœ¨äºæ­¤å¤„------------------
        // ç”±äºBossGroupä¸WorkGroupéƒ½å±äº:NioEventLoop,æ‰€ä»¥debugæœ‰ä¸€äº›éš¾ç‚¹.
        // åœ¨å†…å­˜ä¸­æ˜¯æœ‰å­˜åœ¨ä¸¤ä¸ªNioEventLoopå¯¹è±¡çš„.
        // childGroup(NioEventLoop)æ³¨å†ŒNioSocketChannel
        // ****************************************************
        // ****************************************************
        childGroup.register(child).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    forceClose(child, future.cause());
                }
            }
        });
    } catch (Throwable t) {
        forceClose(child, t);
    }
} // end 
</code></pre></div></div>
<h3 id="3å¦‚ä½•debug">(3).å¦‚ä½•debug?</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EventLoopGroup bossGroup = new NioEventLoopGroup(1);
EventLoopGroup workerGroup = new NioEventLoopGroup(1);
</code></pre></div></div>
<blockquote>
  <p>EventLoopåœ¨å†…å­˜ä¸­æœ‰ä¸¤ä¸ªå¯¹è±¡çš„,æ‰€ä»¥,æ–­ç‚¹éƒ½æ˜¯æ‰“åœ¨NioEventLoop.runæ–¹æ³•é‡Œ.é‚£åˆ°åº•è¦å¦‚ä½•è·Ÿè¸ªå‘¢?<br />
  å¯ä»¥é’ˆå¯¹è¿æ¥å’Œè¯»å†™åˆ†åˆ«jstackçš„è·Ÿè¸ª,æŸ¥çœ‹çº¿ç¨‹çš„è°ƒç”¨é“¾åˆ°åº•æ˜¯å±äºBossGroupè¿˜æ˜¯WorkGroup.<br />
  åœ¨NioEventLoop.processSelectedKeysOptimizedæ–¹æ³•é‡Œ,å¢åŠ æ¡ä»¶æ–­ç‚¹.<br />
    å¦‚æœk.attachmentæ˜¯:NioServerSocketChannelåˆ™äº‹ä»¶å¤„ç†æ˜¯å±äº:ACCEPT.<br />
    å¦‚æœk.attachmentæ˜¯:NioSocketChannelåˆ™äº‹ä»¶å¤„ç†å±äº:READ/WRITE<br />
    è®¾ç½®æ¡ä»¶æ¡ä»¶è¡¨è¾¾å¼ä¸º:<br />
      [a.getClass().equals(io.netty.channel.socket.nio.NioSocketChannel.class)]</p>
</blockquote>

<p><img src="/assets/netty/imgs/debug-1.png" alt="&quot;NioServerSocketChannel&quot;" />
<img src="/assets/netty/imgs/debug-2.png" alt="&quot;NioSocketChannel&quot;" />
<img src="/assets/netty/imgs/debug-3.png" alt="&quot;Eclipseè®¾ç½®æ¡ä»¶æ–­ç‚¹&quot;" /></p>

<h3 id="4nioeventlooprun">(4).NioEventLoop.run</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected void run() {
    int selectCnt = 0;
    for (;;) {
        // ... ... 
        try {
            // å¤„ç†Keys
            processSelectedKeys();
        } finally {
            final long ioTime = System.nanoTime() - ioStartTime;
            ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
       }
       // ... ... 
    }// end for
} // end run
</code></pre></div></div>
<h3 id="5nioeventloopprocessselectedkeys">(5).NioEventLoop.processSelectedKeys</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void processSelectedKeys() {
    if (selectedKeys != null) { // true
        processSelectedKeysOptimized();
    } else {
        processSelectedKeysPlain(selector.selectedKeys());
    }
}
</code></pre></div></div>
<h3 id="6nioeventloopprocessselectedkeysoptimized">(6).NioEventLoop.processSelectedKeysOptimized</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void processSelectedKeysOptimized() {
    for (int i = 0; i &lt; selectedKeys.size; ++i) {
        final SelectionKey k = selectedKeys.keys[i];
        selectedKeys.keys[i] = null;
        
        // ********************************************************
        // *******************************æç¤º*********************
        // NioServerSocketChannel ä»£è¡¨NioEventLoopå¤„ç†çš„æ˜¯ACCEPTäº‹ä»¶
        // NioSocketChannel ä»£è¡¨NioEventLoopå¤„ç†çš„æ˜¯READ/WRITEäº‹ä»¶
        // a = NioSocketChannel 
        // ********************************************************
        final Object a = k.attachment();
    
        if (a instanceof AbstractNioChannel) {
            // å¤„ç†å•ä¸ªkeyäº‹ä»¶
            processSelectedKey(k, (AbstractNioChannel) a);
        } else {
            @SuppressWarnings("unchecked")
            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;
            processSelectedKey(k, task);
        }
    
        if (needsToSelectAgain) {
            // null out entries in the array to allow to have it GC'ed once the Channel close
            // See https://github.com/netty/netty/issues/2363
            selectedKeys.reset(i + 1);
    
            selectAgain();
            i = -1;
        }
    }
} // end processSelectedKeysOptimized
</code></pre></div></div>

<h3 id="7nioeventloopprocessselectedkey">(7).NioEventLoop.processSelectedKey</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    // **************************************************************************
    // unsafe = AbstractNioMessageChannel$NioMessageUnsafe ä»£è¡¨NioEventLoopå¤„ç†çš„æ˜¯ACCEPTäº‹ä»¶
    // unsafe = io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe ä»£è¡¨NioEventLoopå¤„ç†çš„æ˜¯READ/WRITEäº‹ä»¶
    // æ­¤å¤„unsafe = io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe
    // æ­¤:å¤„å¤„ç†çš„æ˜¯Clientå‘é€è¿‡æ¥çš„æ¶ˆæ¯("hello world")
    // **************************************************************************
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();
    
    if (!k.isValid()) { // false
        final EventLoop eventLoop;
        try {
            eventLoop = ch.eventLoop();
        } catch (Throwable ignored) {
            // If the channel implementation throws an exception because there is no event loop, we ignore this
            // because we are only trying to determine if ch is registered to this event loop and thus has authority
            // to close ch.
            return;
        }
        // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
        // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
        // still healthy and should not be closed.
        // See https://github.com/netty/netty/issues/5125
        if (eventLoop == this) {
            // close the channel if the key is not valid anymore
            unsafe.close(unsafe.voidPromise());
        }
        return;
    }
    
    try {
        int readyOps = k.readyOps();
        // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
        // the NIO JDK channel implementation may throw a NotYetConnectedException.
        if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) {
            // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
            // See https://github.com/netty/netty/issues/924
            int ops = k.interestOps();
            ops &amp;= ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);
    
            unsafe.finishConnect();
        }
    
        // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
        if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) {
            // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
            ch.unsafe().forceFlush();
        }
    
        // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
        // to a spin loop
        // true
        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            // unsafe  = io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe
            // è°ƒç”¨è¯»å–æ¶ˆæ¯
            unsafe.read();
        }
    } catch (CancelledKeyException ignored) {
        unsafe.close(unsafe.voidPromise());
    }
}// end 
</code></pre></div></div>
<h3 id="8niosocketchannelniosocketchannelunsaferead">(8).NioSocketChannel$NioSocketChannelUnsafe.read</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final void read() {
    final ChannelConfig config = config();
    if (shouldBreakReadReady(config)) { // false
        clearReadPending();
        return;
    }  // end if
    
    // DefaultChannelPipeline
    // {
    //   (DelimiterBasedFrameDecoder#0 = io.netty.handler.codec.DelimiterBasedFrameDecoder), 
    //   (StringDecoder#0 = io.netty.handler.codec.string.StringDecoder)
    //   (StringEncoder#0 = io.netty.handler.codec.string.StringEncoder)
    //   (TelnetServerHandler#0 = io.netty.example.telnet.TelnetServerHandler)
    // }
    final ChannelPipeline pipeline = pipeline();
    
    // è·å–ç¼“å­˜åˆ†é…ç®¡ç†å™¨
    // allocator = io.netty.buffer.PooledByteBufAllocator
    final ByteBufAllocator allocator = config.getAllocator();
    // allocHandle = io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl
    final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();
    allocHandle.reset(config);
    
    ByteBuf byteBuf = null;
    boolean close = false;
    try {
        do {
            // ******************************************************************
            // åˆ›å»ºByteBufå¯¹è±¡,å¹¶ä»SocketChannelä¸­è¯»å–æ•°æ®åˆ°:ByteBufä¸­
            // ******************************************************************
            // allocHandle = io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl
            // åˆ›å»ºä¸€ä¸ªByteBufå¯¹è±¡(PooledByteBufAllocator)
            byteBuf = allocHandle.allocate(allocator);
            
            // è¯»å–(SocketChannel)æ•°æ®åˆ°ByteBufä¸­
            allocHandle.lastBytesRead(doReadBytes(byteBuf));
            if (allocHandle.lastBytesRead() &lt;= 0) {
                // nothing was read. release the buffer.
                byteBuf.release();
                byteBuf = null;
                close = allocHandle.lastBytesRead() &lt; 0;
                if (close) {
                    // There is nothing left to read as we received an EOF.
                    readPending = false;
                }
                break;
            }
    
            allocHandle.incMessagesRead(1);
            readPending = false;
            pipeline.fireChannelRead(byteBuf);
            byteBuf = null;
        } while (allocHandle.continueReading());
    
        allocHandle.readComplete();
        pipeline.fireChannelReadComplete();
    
        if (close) {
            closeOnRead(pipeline);
        }
    } catch (Throwable t) {
        handleReadException(pipeline, byteBuf, t, close, allocHandle);
    } finally {
        // Check if there is a readPending which was not processed yet.
        // This could be for two reasons:
        // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
        // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
        //
        // See https://github.com/netty/netty/issues/2254
        if (!readPending &amp;&amp; !config.isAutoRead()) {
            removeReadOp();
        }
    }
} // end read
</code></pre></div></div>
<h3 id="9æ€»ç»“">(9).æ€»ç»“</h3>

:ET