<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>李新的博客</title>
    <description>昵称码农，热爱技术&amp;喜欢探索源码。很高兴能在这里与你分享我对技术和生活的思考。</description>
    <link>http://localhost:4000//</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Mon, 26 Oct 2020 21:42:33 +0800</pubDate>
    <lastBuildDate>Mon, 26 Oct 2020 21:42:33 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>Reactor Stream源码(Schedulers)</title>
        <description>&lt;h3 id=&quot;1schedulers&quot;&gt;(1).Schedulers&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//1. 创建线程
Schedulers.newElastic(&quot;selfTrade-thread&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2schedulersnewelastic&quot;&gt;(2).Schedulers.newElastic&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 1. 
public static Scheduler newElastic(String name) {
    // name = &quot;selfTrade-thread&quot;
    return newElastic(name, ElasticScheduler.DEFAULT_TTL_SECONDS);
  }
  
  // 2.
  public static Scheduler newElastic(String name, int ttlSeconds) {
    // name = &quot;selfTrade-thread&quot;
    // ttlSeconds = 60 
    return newElastic(name, ttlSeconds, false);
  }
  
  // 3.
  public static Scheduler newElastic(String name, int ttlSeconds) {
      // name = &quot;selfTrade-thread&quot;
      // ttlSeconds = 60 
      return newElastic(name, ttlSeconds, false);
  }
  
  // 4. 
  public static Scheduler newElastic(String name, int ttlSeconds, boolean daemon) 
      return newElastic(
         ttlSeconds,
         // 4.1 
         new ReactorThreadFactory(     
               // selfTrade-thread
                name, 
                // 统计信息
                // AtomicLong COUNTER = new AtomicLong();
                ElasticScheduler.COUNTER, 
                // false
                daemon, 
                // 
                false,
                // 异常处理方法
		     Schedulers::defaultUncaughtException)
         );
	}
 
 // 5 
 // 
 static volatile Factory factory = DEFAULT;
 static final Factory DEFAULT = new Factory() { };
 public static Scheduler newElastic(int ttlSeconds, ThreadFactory threadFactory) {
    // ttlSeconds = 60
    // threadFactory = reactor.core.scheduler.ReactorThreadFactory
    // fatory 指向了自己内部的一个属性:DEFAULT
    // factory = Schedulers.DEFAULT
    return factory.newElastic(ttlSeconds, threadFactory);
 }
 
 
 
 public interface Schedulers.Factory {
     // 6. 
     default Scheduler newElastic(int ttlSeconds, ThreadFactory threadFactory) {
       // ttlSeconds = 60 
       // threadFactory = reactor.core.scheduler.ReactorThreadFactory
       // 创建ElasticScheduler并返回(看第5点)
       return new ElasticScheduler(threadFactory, ttlSeconds);
	 }
  
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;3reactorthreadfactory&quot;&gt;(3).ReactorThreadFactory&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package reactor.core.scheduler;

class ReactorThreadFactory 
       implements ThreadFactory,
                  Supplier&amp;lt;String&amp;gt;,
                  Thread.UncaughtExceptionHandler {
    // 线程名称
    final private String                        name;
	// 统计信息
   final private AtomicLong                    counterReference;
   // 是否守护线程 false
	final private boolean                       daemon;
   // 是否阻塞并拒绝 false
	final private boolean                       rejectBlocking;

    @Nullable
	final private BiConsumer&amp;lt;Thread, Throwable&amp;gt; uncaughtExceptionHandler;
   
	ReactorThreadFactory(String name,
			AtomicLong counterReference,
			boolean daemon,
			boolean rejectBlocking,
			@Nullable BiConsumer&amp;lt;Thread, Throwable&amp;gt; uncaughtExceptionHandler) {
		this.name = name;
		this.counterReference = counterReference;
		this.daemon = daemon;
		this.rejectBlocking = rejectBlocking;
            // 异常处理方式
		this.uncaughtExceptionHandler = uncaughtExceptionHandler;
	}
 
 
 @Override
	public final Thread newThread(@NotNull Runnable runnable) {
           // 创建线程名称
		String newThreadName = name + &quot;-&quot; + counterReference.incrementAndGet();
		// rejectBlocking  = false
           Thread t = rejectBlocking
                      ? new NonBlockingThread(runnable, newThreadName)
                      : new Thread(runnable, newThreadName);
		if (daemon) {
              t.setDaemon(true);
		}
		if (uncaughtExceptionHandler != null) {
              t.setUncaughtExceptionHandler(this);
		}
		return t;
	}

   // 拒绝策略
	@Override
	public void uncaughtException(Thread t, Throwable e) {
        if (uncaughtExceptionHandler == null) {
            return;
        }
        uncaughtExceptionHandler.accept(t,e);
	}
    
    // 获得线程名称
	@Override
	public final String get() {
        return name;
	}

    static final class NonBlockingThread extends Thread implements NonBlocking {
        public NonBlockingThread(Runnable target, String name) {
            super(target, name);
         }
    }// end NonBlockingThread

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;4scheduler&quot;&gt;(4).Scheduler&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Scheduler extends Disposable {
    
    Disposable schedule(Runnable task);
    
    default long now(TimeUnit unit) {
        return unit.convert(System.currentTimeMillis(), TimeUnit.MILLISECONDS);
	}
 
     Worker createWorker();
     
    default void dispose() {
	 }
     
    default void start() {
	 }
    
     interface Worker extends Disposable {
         Disposable schedule(Runnable task);
         default Disposable schedule(Runnable task, long delay, TimeUnit unit) {
             throw Exceptions.failWithRejectedNotTimeCapable();
	      }
       
          default Disposable schedulePeriodically(Runnable task, long initialDelay, long period, TimeUnit unit) {
                throw Exceptions.failWithRejectedNotTimeCapable();
	       }
     } //end Worker    
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;5elasticscheduler&quot;&gt;(5).ElasticScheduler&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final class ElasticScheduler 
      // Reactor自定义的线程调度方法
      implements Scheduler, 
      // 返回JDK自带的线程池
      Supplier&amp;lt;ScheduledExecutorService&amp;gt;,
      //  
      Scannable {
    // 每创建一个线程 COUNTER++
    static final AtomicLong COUNTER = new AtomicLong();
    
    // 创建回收线程,并设置为守护线程 
    static final ThreadFactory EVICTOR_FACTORY = r -&amp;gt; {
		Thread t = new Thread(r, &quot;elastic-evictor-&quot; + COUNTER.incrementAndGet());
		t.setDaemon(true);
		return t;
	};
     
   static final CachedService SHUTDOWN = new CachedService(null);
	static final int DEFAULT_TTL_SECONDS = 60;
	final ThreadFactory factory;
	final int ttlSeconds;
	final Deque&amp;lt;ScheduledExecutorServiceExpiry&amp;gt; cache;
	final Queue&amp;lt;CachedService&amp;gt; all;
	final ScheduledExecutorService evictor;
	volatile boolean shutdown;
    
    // 1. 
    ElasticScheduler(ThreadFactory factory, int ttlSeconds) {
           // ttlSeconds = 60 
		if (ttlSeconds &amp;lt; 0) {
			throw new IllegalArgumentException(&quot;ttlSeconds must be positive, was: &quot; + ttlSeconds);
		}
		this.ttlSeconds = ttlSeconds;
           // factory = reactor.core.scheduler.ReactorThreadFactory
		this.factory = factory;
           // *******************************
           // 创建双端队列
           // *******************************
		this.cache = new ConcurrentLinkedDeque&amp;lt;&amp;gt;();
		this.all = new ConcurrentLinkedQueue&amp;lt;&amp;gt;();
           // ***************************************
           // 创建回收线程池 core:1 max:Integer.MAX_VALUE
           // ***************************************
		this.evictor = Executors.newScheduledThreadPool(1, EVICTOR_FACTORY);
		// 启动线程回收
           this.evictor.scheduleAtFixedRate(
                           this::eviction, 
                            // 延迟60秒
				ttlSeconds,
                            // 间隔60秒
				ttlSeconds,
                            // 单位为秒
				TimeUnit.SECONDS);
	}
    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;6总结&quot;&gt;(6).总结&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;创建Schedulers.ElasticScheduler,
它的数据结构是:
ThreadFactory(reactor.core.scheduler.ReactorThreadFactory)
ScheduledExecutorService&lt;/li&gt;
  &lt;li&gt;实际就是创建了&lt;font color=&quot;red&quot;&gt;ScheduledExecutorService&lt;/font&gt;的子类&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Reactor-Stream-Schedulers.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Reactor-Stream-Schedulers.html</guid>
        
        <category>ProjectReactorStream</category>
        
        
      </item>
    
      <item>
        <title>Reactor Stream接口分析</title>
        <description>&lt;h3 id=&quot;1publisher&quot;&gt;(1).Publisher&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package org.reactivestreams;

public interface Publisher&amp;lt;T&amp;gt; {
    
    public void subscribe(Subscriber&amp;lt;? super T&amp;gt; s);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2subscriber&quot;&gt;(2).Subscriber&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package org.reactivestreams;

public interface Subscriber&amp;lt;T&amp;gt; {
    public void onSubscribe(Subscription s);
    public void onNext(T t);
    public void onError(Throwable t);
    public void onComplete();    
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;3subscription&quot;&gt;(3).Subscription&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;package org.reactivestreams;
public interface Subscription {
    public void request(long n);
    public void cancel();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;4总结&quot;&gt;(4).总结&lt;/h3&gt;
&lt;p&gt;Publisher    :   发布者&lt;br /&gt;
Subscriber   :   订阅者( 当调用Publisher.subscribe(Subscriber&amp;lt;? super T&amp;gt; s )时,会触发:Subscriber.onSubscribe(Subscription s) )&lt;br /&gt;
Subscription  :   发布者与订阅者的一次订阅周期,一旦调用cancel去掉订阅,则发布者不会再推送消息.&lt;/p&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Reactor-Stream-Interface-Analyse.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Reactor-Stream-Interface-Analyse.html</guid>
        
        <category>ProjectReactorStream</category>
        
        
      </item>
    
      <item>
        <title>Reactor Stream源码(Flux.subscribe)</title>
        <description>&lt;h3 id=&quot;1案例&quot;&gt;(1).案例&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Flux.just(&quot;1&quot;,&quot;2&quot;)
    .subscribe(c-&amp;gt;{
            System.out.println(&quot;consumer:&quot; + c);
    });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;2fluxsubscribe&quot;&gt;(2).Flux.subscribe&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final Disposable subscribe(Consumer&amp;lt;? super T&amp;gt; consumer) {
    // consumer = help.lixin.samples.Flux2Test$$Lambda$7
    Objects.requireNonNull(consumer, &quot;consumer&quot;);
    return subscribe(consumer, null, null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;3fluxsubscribe&quot;&gt;(3).Flux.subscribe&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final Disposable subscribe(
        @Nullable Consumer&amp;lt;? super T&amp;gt; consumer,
        @Nullable Consumer&amp;lt;? super Throwable&amp;gt; errorConsumer,
        @Nullable Runnable completeConsumer) {
           // consumer 订阅
           // errorConsumer 错误处理
           // completeConsumer 完成处理
    return subscribe(consumer, errorConsumer, completeConsumer, (Context) null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;4fluxsubscribe&quot;&gt;(4).Flux.subscribe&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final Disposable subscribe(
        @Nullable Consumer&amp;lt;? super T&amp;gt; consumer,
        @Nullable Consumer&amp;lt;? super Throwable&amp;gt; errorConsumer,
        @Nullable Runnable completeConsumer,
        // null
        @Nullable Context initialContext) {
    return subscribeWith(
        // 创建:reactor.core.publisher.LambdaSubscriber
        // 包课着正确消费者/错误消费者/完成处理等...
        new LambdaSubscriber&amp;lt;&amp;gt;(consumer, errorConsumer,completeConsumer,null,initialContext)
    );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;5lambdasubscriber&quot;&gt;(5).LambdaSubscriber&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface CoreSubscriber&amp;lt;T&amp;gt; extends Subscriber&amp;lt;T&amp;gt; {}

interface InnerConsumer&amp;lt;I&amp;gt;
          extends CoreSubscriber&amp;lt;I&amp;gt;, 
          Scannable {             
}

final class LambdaSubscriber&amp;lt;T&amp;gt;
		implements InnerConsumer&amp;lt;T&amp;gt;, 
             Disposable {      
}
// LambdaSubscriber 属于:Subscriber的实现类
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;6fluxsubscribewith&quot;&gt;(6).Flux.subscribeWith&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final &amp;lt;E extends Subscriber&amp;lt;? super T&amp;gt;&amp;gt; E subscribeWith(E subscriber) {
    // reactor.core.publisher.LambdaSubscriber
    // 调用最终的subscribe
    subscribe(subscriber);
    return subscriber;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;7fluxsubscribe&quot;&gt;(7).Flux.subscribe&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void subscribe(Subscriber&amp;lt;? super T&amp;gt; actual) {
    // actual = reactor.core.publisher.LambdaSubscriber
    
    // ***************************************************
    // 把FluxArray转换成:CorePublisher
    // this = FluxArray
    // ***************************************************
    CorePublisher publisher = Operators.onLastAssembly(this);
    
    // ***************************************************
    // 把reactor.core.publisher.LambdaSubscriber
    // 转换成: CoreSubscriber
    // ***************************************************
    CoreSubscriber subscriber = Operators.toCoreSubscriber(actual);

    try {
        // 从上面的分析得了:publisher不是OptimizableOperator的子类
        if (publisher instanceof OptimizableOperator) {  // false
            OptimizableOperator operator = (OptimizableOperator) publisher;
            while (true) {
                subscriber = operator.subscribeOrReturn(subscriber);
                if (subscriber == null) {
                    return;
                }
                
                OptimizableOperator newSource = operator.nextOptimizableSource();
                
                if (newSource == null) {
                    publisher = operator.source();
						break;
                } //end if
                
                operator = newSource;
            } //end while
        } //end if
        
        
        // ***************************************************
        // reactor.core.publisher.FluxArray
        //   .subscribe(reactor.core.publisher.LambdaSubscriber s)
        // ***************************************************
        publisher.subscribe(subscriber);
    } catch (Throwable e) {
        Operators.reportThrowInSubscribe(subscriber, e);
        return;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;8fluxarraysubscribe&quot;&gt;(8).FluxArray.subscribe&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void subscribe(CoreSubscriber&amp;lt;? super T&amp;gt; actual) {
    // actual = reactor.core.publisher.LambdaSubscriber
    // array = [&quot;1&quot;,&quot;2&quot;]
    subscribe(actual, array);
}

public static &amp;lt;T&amp;gt; void subscribe(CoreSubscriber&amp;lt;? super T&amp;gt; s, T[] array) {
        // s = reactor.core.publisher.LambdaSubscriber
        // array = [&quot;1&quot;,&quot;2&quot;]
        if (array.length == 0) {  // false
            Operators.complete(s);
            return;
        }// end if
        
        if (s instanceof ConditionalSubscriber) { // false
            s.onSubscribe(new ArrayConditionalSubscription&amp;lt;&amp;gt;((ConditionalSubscriber&amp;lt;? super T&amp;gt;) s, array));
        } else {
            // *********************Subscriber.onSubscribe*************************
            // reactor.core.publisher.LambdaSubscriber.onSubscribe
            // 
            // **********************************************
            s.onSubscribe(new ArraySubscription&amp;lt;&amp;gt;(s, array));
        } //end else
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;9lambdasubscriberonsubscribe&quot;&gt;(9).LambdaSubscriber.onSubscribe&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// reactor.core.publisher.FluxArray$ArraySubscription
public final void onSubscribe(Subscription s) {
    // s = reactor.core.publisher.FluxArray$ArraySubscription
    // s包裹着:数组和LambdaSubscriber
    if (Operators.validate(subscription, s)) { // true
            // 订阅者
            this.subscription = s;
            
            if (subscriptionConsumer != null) { // false
                try {
                    subscriptionConsumer.accept(s);
                } catch (Throwable t) {
                    Exceptions.throwIfFatal(t);
                    s.cancel();
                    onError(t);
                }
            } else {
                // s = FluxArray$ArraySubscription
                s.request(Long.MAX_VALUE);
            } //end else
    } //end if
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;10fluxarrayarraysubscription&quot;&gt;(10).FluxArray.ArraySubscription&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void request(long n) {
    // Long.MAX_VALUE
    if (Operators.validate(n)) { // true
            if (Operators.addCap(REQUESTED, this, n) == 0) { // true
                if (n == Long.MAX_VALUE) { // true
                   // invoker fastPath
                    fastPath();
                } else {
                    slowPath(n);
                }
            } //end if
    } //end if
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;11fluxarrayarraysubscriptionfastpath&quot;&gt;(11).FluxArray.ArraySubscription.fastPath&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void fastPath() {
    // a = [1, 2]
    final T[] a = array;
    // len = 2
    final int len = a.length;
    // s = reactor.core.publisher.LambdaSubscriber
    final Subscriber&amp;lt;? super T&amp;gt; s = actual;

    // 遍历数组
    for (int i = index; i != len; i++) {
        // 是否设置了取消
        if (cancelled) {
                return;
        }

        // 数组第N个元素
        T t = a[i];

        
        if (t == null) {
            // 为空的情况下调用:onError
            s.onError(new NullPointerException(&quot;The &quot; + i + &quot;th array element was null&quot;));
            return;
        }
        // ************************************
        // onNext调用
        // ************************************
        // 最后调用onNext方法
        s.onNext(t);
    }// end for
        
    if (cancelled) {
            return;
    } //end if
        
    // 最后调用:onCompelete()方法    
    s.onComplete();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;12总结&quot;&gt;(12).总结&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Flux.just()方法.&lt;br /&gt;
 会把传入的数据封装成:FluxArray(它属于Publisher的子类)&lt;/li&gt;
  &lt;li&gt;Flux.subscribe(Consumer c)方法.&lt;br /&gt;
 会把Consumer函数封装成:LambdaSubscriber(它属于Subscriber的子类)&lt;/li&gt;
  &lt;li&gt;Flux.subscribe(Subscriber) 最后实际是这样调用的:&lt;br /&gt;
 FluxArray.subscribe(LambdaSubscriber s)&lt;/li&gt;
  &lt;li&gt;把数据和消费者封装成:ArraySubscription(属于:Subscription的子类)&lt;br /&gt;
 LambdaSubscriber
     .onSubscribe(
         new ArraySubscription(LambdaSubscriber,
         [“1”,”2”])
 );&lt;br /&gt;
 注意:ArraySubscription持有:LambdaSubscriber和数组&lt;/li&gt;
  &lt;li&gt;设置一次订阅多少&lt;br /&gt;
 ArraySubscription.request(Long.MAX_VALUE)&lt;/li&gt;
  &lt;li&gt;进行快速消费或缓存消费&lt;br /&gt;
T[] data = [“1”,”2”];
 for(int i=0;i&amp;lt;data.length;i++){
     如果数组元素有一个为空:
     则调用:ArraySubscription.onError(…)
     否则调用:ArraySubscription.onNext(…)
 }
 ArraySubscription.onComplete()&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Reactor-Stream-Flux-subscribe.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Reactor-Stream-Flux-subscribe.html</guid>
        
        <category>ProjectReactorStream</category>
        
        
      </item>
    
      <item>
        <title>Reactor Stream源码(Flux.just)</title>
        <description>&lt;h3 id=&quot;1flux类关系图&quot;&gt;(1).Flux类关系图&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 注意该类是抽象类
public abstract class Flux&amp;lt;T&amp;gt; 
               // 实现了reactor.core.CorePublisher
               // CorePublisher是Publisher的增加
               implements CorePublisher&amp;lt;T&amp;gt; {
}

public interface CorePublisher&amp;lt;T&amp;gt; 
       // org.reactivestreams.Publisher
       extends Publisher&amp;lt;T&amp;gt; {
    
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2fluxjust12&quot;&gt;(2).Flux.just(“1”,”2”)&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; Flux&amp;lt;T&amp;gt; just(T... data) {
    // [&quot;1&quot;,&quot;2&quot;]
    return fromArray(data);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;3fluxfromarray&quot;&gt;(3).Flux.fromArray&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static &amp;lt;T&amp;gt; Flux&amp;lt;T&amp;gt; fromArray(T[] array) {
    // [&quot;1&quot;,&quot;2&quot;]
    if (array.length == 0) { // false
        return empty();
    }
    if (array.length == 1) { // false
        return just(array[0]);
    }
    
    // 创建FluxArray包裹数组
    // 调用onAssembly
    return onAssembly(new FluxArray&amp;lt;&amp;gt;(array));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;4fluxarray&quot;&gt;(4).FluxArray&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;FluxArray既是Flux的子类,而且还实现了:Publisher&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final class FluxArray&amp;lt;T&amp;gt; 
      // 继承于:reactor.core.publisher.Flux
      extends Flux&amp;lt;T&amp;gt; 
      // reactor.core.Fuseable
      implements Fuseable, 
      // reactor.core.publisher.SourceProducer
      SourceProducer&amp;lt;T&amp;gt; {
    
}

interface SourceProducer&amp;lt;O&amp;gt; 
     // reactor.core.Scannable
     extends Scannable, 
     // org.reactivestreams.Publisher
             Publisher&amp;lt;O&amp;gt; {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;5-fluxonassembly&quot;&gt;(5). Flux.onAssembly&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// onAssembly 包裹结果集,可以Hooks可以TRACE整个过程
protected static &amp;lt;T&amp;gt; Flux&amp;lt;T&amp;gt; onAssembly(Flux&amp;lt;T&amp;gt; source) {
    // source = FluxArray
    Function&amp;lt;Publisher, Publisher&amp;gt; hook = Hooks.onEachOperatorHook;
    if(hook != null) { // false
        source = (Flux&amp;lt;T&amp;gt;) hook.apply(source);
    }
    
    if (Hooks.GLOBAL_TRACE) {
            AssemblySnapshot stacktrace = new AssemblySnapshot(null, Traces.callSiteSupplierFactory.get());
            source = (Flux&amp;lt;T&amp;gt;) Hooks.addAssemblyInfo(source, stacktrace);
    }
    return source;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;6总结&quot;&gt;(6).总结&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Flux.just会把数组包裹成:reactor.core.publisher.FluxArray&lt;/li&gt;
  &lt;li&gt;返回:reactor.core.publisher.FluxArray,因为FluxArray继承于:Flux并实现了:Publisher&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Reactor-Stream-Flux-just.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Reactor-Stream-Flux-just.html</guid>
        
        <category>ProjectReactorStream</category>
        
        
      </item>
    
      <item>
        <title>Netty源码(ServerBootstrap)</title>
        <description>&lt;h3 id=&quot;1serverbootstrap继承关系&quot;&gt;(1).ServerBootstrap继承关系&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;io.netty.bootstrap.ServerBootstrap 
    extends io.netty.bootstrap.AbstractBootstrap

// ServerBootstrap只是继承了:AbstractBootstrap
// AbstractBootstrap 主要是针对BossGroup的一些函数定义
// ServerBootstrap   主要是针对WorkGroup的一些函数定义
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2serverbootstrap创建与使用&quot;&gt;(2).ServerBootstrap创建与使用&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EventLoopGroup bossGroup = new NioEventLoopGroup(1);
EventLoopGroup workerGroup = new NioEventLoopGroup();
try {
    // 2.创建ServerBootstrap
    ServerBootstrap b = new ServerBootstrap();
    // 3.进行配置
    // group配置
    b.group(bossGroup, workerGroup)
     .channel(NioServerSocketChannel.class)
     .handler(new LoggingHandler(LogLevel.INFO))
    .childHandler(new TelnetServerInitializer(sslCtx));

    b.bind(PORT).sync().channel().closeFuture().sync();
} finally {
    bossGroup.shutdownGracefully();
    workerGroup.shutdownGracefully();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3创建serverbootstrap&quot;&gt;(3).创建ServerBootstrap&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 无参构造器
public ServerBootstrap() { }

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4serverbootstrapgroup配置&quot;&gt;(4).ServerBootstrap.group配置&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ServerBootstrap group(EventLoopGroup group) {
    return group(group, group);
}

public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup) {
    // 5. 调用父类:AbstractBootstrap构造器
    super.group(parentGroup);
    
    if (this.childGroup != null) {
        throw new IllegalStateException(&quot;childGroup set already&quot;);
    }
    // 构建childGroup
    this.childGroup = ObjectUtil.checkNotNull(childGroup, &quot;childGroup&quot;);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5abstractbootstrap构造器&quot;&gt;(5).AbstractBootstrap构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;volatile EventLoopGroup group;

public B group(EventLoopGroup group) {
    ObjectUtil.checkNotNull(group, &quot;group&quot;);
    if (this.group != null) {
        throw new IllegalStateException(&quot;group set already&quot;);
    }
    this.group = group;
    return self();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6abstractbootstrapchannel配置&quot;&gt;(6).AbstractBootstrap.channel配置&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public B channel(Class&amp;lt;? extends C&amp;gt; channelClass) {
    // channelClass = io.netty.channel.socket.nio.NioServerSocketChannel
    // 8.AbstractBootstrap.channelFactory
    return channelFactory(
        // 7.创建ReflectiveChannelFactory
        new ReflectiveChannelFactory&amp;lt;C&amp;gt;(ObjectUtil.checkNotNull(channelClass, &quot;channelClass&quot;))
    );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7reflectivechannelfactory-构造器&quot;&gt;(7).ReflectiveChannelFactory 构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ReflectiveChannelFactory&amp;lt;T extends Channel&amp;gt; implements ChannelFactory&amp;lt;T&amp;gt; {
    private final Constructor&amp;lt;? extends T&amp;gt; constructor;

    public ReflectiveChannelFactory(Class&amp;lt;? extends T&amp;gt; clazz) {
        ObjectUtil.checkNotNull(clazz, &quot;clazz&quot;);
        try {
            this.constructor = clazz.getConstructor();
        } catch (NoSuchMethodException e) {
            throw new IllegalArgumentException(&quot;Class &quot; + StringUtil.simpleClassName(clazz) +
                    &quot; does not have a public non-arg constructor&quot;, e);
        }
    } //end 构造器
    
    public T newChannel() {
        try {
            return constructor.newInstance();
        } catch (Throwable t) {
            throw new ChannelException(&quot;Unable to create Channel from class &quot; + constructor.getDeclaringClass(), t);
        }
    } // end newChannel
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;8abstractbootstrapchannelfactory&quot;&gt;(8).AbstractBootstrap.channelFactory&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public B channelFactory(ChannelFactory&amp;lt;? extends C&amp;gt; channelFactory) {
    // channelFactory = ReflectiveChannelFactory(NioServerSocketChannel.class)
    ObjectUtil.checkNotNull(channelFactory, &quot;channelFactory&quot;);
    
    if (this.channelFactory != null) { // false
        throw new IllegalStateException(&quot;channelFactory set already&quot;);
    }
    // 设置Channel工厂
    this.channelFactory = channelFactory;
    return self();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;9abstractbootstraphandler-配置日志&quot;&gt;(9).AbstractBootstrap.handler 配置日志&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 配置bossHadnler
private volatile ChannelHandler handler;

public B handler(ChannelHandler handler) {
    // handler = io.netty.handler.logging.LoggingHandler
    this.handler = ObjectUtil.checkNotNull(handler, &quot;handler&quot;);
    return self();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;10serverbootstrapchildhandler&quot;&gt;(10).ServerBootstrap.childHandler&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 配置workHandler

private volatile ChannelHandler childHandler;

public ServerBootstrap childHandler(ChannelHandler childHandler) {
    // childHandler = io.netty.example.telnet.TelnetServerInitializer
    this.childHandler = ObjectUtil.checkNotNull(childHandler, &quot;childHandler&quot;);
    return this;
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;11abstractbootstrapbind&quot;&gt;(11).AbstractBootstrap.bind&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ChannelFuture bind(int inetPort) {
    // inetPort = 8023
    return bind(new InetSocketAddress(inetPort));
}

public ChannelFuture bind(SocketAddress localAddress) {
    // localAddress = 0.0.0.0/0.0.0.0:8023
    
    // 验证:channelFactory/group都不能为空
    validate();
    
    // 调用doBind
    return doBind(ObjectUtil.checkNotNull(localAddress, &quot;localAddress&quot;));
}

private ChannelFuture doBind(final SocketAddress localAddress) {
    // 12. 初始化并注册
    final ChannelFuture regFuture = initAndRegister();
    final Channel channel = regFuture.channel();
    if (regFuture.cause() != null) {
            return regFuture;
    } //end if
    
    if (regFuture.isDone()) {
        // At this point we know that the registration was complete and successful.
        ChannelPromise promise = channel.newPromise();
        doBind0(regFuture, channel, localAddress, promise);
        return promise;
    } else {
        // Registration future is almost always fulfilled already, but just in case it's not.
        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
        regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an
                        // IllegalStateException once we try to access the EventLoop of the Channel.
                        promise.setFailure(cause);
                    } else {
                        // Registration was successful, so set the correct executor to use.
                        // See https://github.com/netty/netty/issues/2586
                        promise.registered();
                        doBind0(regFuture, channel, localAddress, promise);
                    }
                }
            }); //end addListener
            return promise;
    } //end else
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;12abstractbootstrapinitandregister&quot;&gt;(12).AbstractBootstrap.initAndRegister&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 初始化:ChannelFuture
final ChannelFuture initAndRegister() {
    Channel channel = null;
    try {
        // *****************************************************************
        // 通过反射工厂创建出:io.netty.channel.socket.nio.NioServerSocketChannel
        // NioServerSocketChannel另起一遍进行分析
        // *****************************************************************
        channel = channelFactory.newChannel();
        // 13. 调用子类(ServerBootstrap),配置:NioServerSocketChannel
        init(channel);
    } catch (Throwable t) {
        if (channel != null) {
            // channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))
            channel.unsafe().closeForcibly();
            // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
        }
        // as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor
        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
    }
    
    // ****************************************************
    // ****************************************************
    // config().group() == NioEventLoopGroup
    // 往BossGroup(NioEventLoopGroup)中注册:NioServerSocketChannel
    // ****************************************************
    // ****************************************************
    ChannelFuture regFuture = config().group().register(channel);
    
    if (regFuture.cause() != null) {  // false
        if (channel.isRegistered()) {
            channel.close();
        } else {
            channel.unsafe().closeForcibly();
        }
    }
    return regFuture;
} // end initAndRegister
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;13serverbootstrapinit&quot;&gt;(13).ServerBootstrap.init&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 对NioServerSocketChannel进行相关配置
void init(Channel channel) {
    // channel = NioServerSocketChannel
    setChannelOptions(channel, newOptionsArray(), logger);
    setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));

    // DefaultChannelPipeline
    ChannelPipeline p = channel.pipeline();

    // io.netty.channel.nio.NioEventLoopGroup
    // 获得workGroup
   final EventLoopGroup currentChildGroup = childGroup;
   // 获得workgChild
   // io.netty.example.telnet.TelnetServerInitializer
   final ChannelHandler currentChildHandler = childHandler;
   
   // child配置项
   final Entry&amp;lt;ChannelOption&amp;lt;?&amp;gt;, Object&amp;gt;[] currentChildOptions;
    synchronized (childOptions) {
        currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);
    }
    
    // []
    final Entry&amp;lt;AttributeKey&amp;lt;?&amp;gt;, Object&amp;gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);
    
    // **************************************************
    // 在默认的DefaultChannelPipeline的基础上添加一个:io.netty.channel.ChannelHandler
    // **************************************************
    p.addLast(new ChannelInitializer&amp;lt;Channel&amp;gt;() {
        @Override
        public void initChannel(final Channel ch) {
            final ChannelPipeline pipeline = ch.pipeline();
            ChannelHandler handler = config.handler();
            if (handler != null) {
                pipeline.addLast(handler);
            }
            
            // ****************************************
            // 添加任务到队列里
            // ****************************************
            ch.eventLoop().execute(new Runnable() {
                @Override
                public void run() {
                    pipeline.addLast(new ServerBootstrapAcceptor(
                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));
                }
            });
        }
    }); // end addLast
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;14multithreadeventloopgroupnioeventloopgroupregister&quot;&gt;(14).MultithreadEventLoopGroup(NioEventLoopGroup).register&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ChannelFuture register(Channel channel) {
    // channel = NioServerSocketChannel
    // next() --&amp;gt; io.netty.util.concurrent.DefaultEventExecutorChooserFactory$PowerOfTwoEventExecutorChooser
    // next() 方法相当于从多个EventExecutor(NioEventLoop)中选择一个,类似于策略模式
    // next() 返回的类型为:EventExecutor(NioEventLoop)
    return next().register(channel);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;15singlethreadeventloopnioeventloopregister&quot;&gt;(15).SingleThreadEventLoop(NioEventLoop).register&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ChannelFuture register(Channel channel) {
    // channel = NioServerSocketChannel
    return register(new DefaultChannelPromise(channel, this));
}

public ChannelFuture register(final ChannelPromise promise) {
    ObjectUtil.checkNotNull(promise, &quot;promise&quot;);
    // channel() == NioServerSocketChannel
    // ************************************************************************************************************
   // NioServerSocketChannel的构造器在初始化时,会调用父类的构造器:AbstractChannel
   // 而父类构造器会调用:AbstractNioMessageChannel.newUnsafe() 构建出一个:AbstractNioMessageChannel$NioMessageUnsafe
   // ************************************************************************************************************
   
    promise.channel().unsafe().register(this, promise);
    return promise;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;16abstractniomessagechannelniomessageunsaferegister&quot;&gt;(16).AbstractNioMessageChannel.NioMessageUnsafe.register&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// ********************************************************************************************
// AbstractNioMessageChannel.NioMessageUnsafe 继承于:AbstractChannel.AbstractUnsafe
// ********************************************************************************************

public abstract class AbstractChannel extends DefaultAttributeMap implements Channel {
    
    protected abstract class AbstractUnsafe implements Unsafe {
        
        public final void register(EventLoop eventLoop, final ChannelPromise promise) {
            // eventLoop = io.netty.channel.nio.NioEventLoop
            // promise = DefaultChannelPromise
            ObjectUtil.checkNotNull(eventLoop, &quot;eventLoop&quot;);
            
            if (isRegistered()) { // false
                promise.setFailure(new IllegalStateException(&quot;registered to an event loop already&quot;));
                return;
            }
            
            if (!isCompatible(eventLoop)) { // false
                promise.setFailure(
                        new IllegalStateException(&quot;incompatible event loop type: &quot; + eventLoop.getClass().getName()));
                return;
            }

            // 这个方法应该只可能调用一次
            // 给eventLoop赋值
            AbstractChannel.this.eventLoop = eventLoop;

            // 判断:NioEventLoop中的线程是否为当前线程
            // 这个时候,NioEventLoop中的thread的属性还为空中.
            if (eventLoop.inEventLoop()) { // false
                register0(promise);
            } else {
                try {
                 // ***************************************************
                // 调用:SingleThreadEventExecutor(NioEventLoop).execute(....)
                // ***************************************************
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                //     
                } catch (Throwable t) {
                    logger.warn(
                            &quot;Force-closing a channel whose registration task was not accepted by an event loop: {}&quot;,
                            AbstractChannel.this, t);
                    closeForcibly();
                    closeFuture.setClosed();
                    safeSetFailure(promise, t);
                }
            }// 
        } // end register
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;17singlethreadeventexecutornioeventloopexecute&quot;&gt;(17).SingleThreadEventExecutor(NioEventLoop).execute&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void execute(Runnable task) {
    // task = io.netty.channel.AbstractChannel$AbstractUnsafe$1
    ObjectUtil.checkNotNull(task, &quot;task&quot;);
    execute(task, !(task instanceof LazyRunnable) &amp;amp;&amp;amp; wakesUpForTask(task));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;18singlethreadeventexecutornioeventloopexecute&quot;&gt;(18).SingleThreadEventExecutor(NioEventLoop).execute&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void execute(Runnable task, boolean immediate) {
    // task = io.netty.channel.AbstractChannel$AbstractUnsafe.register0
    // immediate = true
    // inEventLoop = false
    boolean inEventLoop = inEventLoop();
    // 添加任务进入队列
    addTask(task);
    if (!inEventLoop) { //!(false)
        // 18.开启线程
        startThread();
        
        if (isShutdown()) {
            boolean reject = false;
            try {
                if (removeTask(task)) {
                    reject = true;
                } // end if
            } catch (UnsupportedOperationException e) {
            }
            
            if (reject) {
                reject();
            } // end if
            
        } // end if
    } // end if

    if (!addTaskWakesUp &amp;amp;&amp;amp; immediate) {
        wakeup(inEventLoop);
    } // end if
}



protected void addTask(Runnable task) {
    ObjectUtil.checkNotNull(task, &quot;task&quot;);
    if (!offerTask(task)) { // !(true)
        reject(task);
    }
} //end addTask


// 线程状态
volatile int state = ST_NOT_STARTED;
// 任务队列
final Queue&amp;lt;Runnable&amp;gt; taskQueue;

final boolean offerTask(Runnable task) {
    // 如果线程的状态是关闭,则拒绝,否则:添加到任务列表中
    if (isShutdown()) { // false
        reject();
    }
    // 添加到任务队列里
    return taskQueue.offer(task);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;19singlethreadeventexecutornioeventloopstartthread&quot;&gt;(19).SingleThreadEventExecutor(NioEventLoop).startThread&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void startThread() {
    // ST_NOT_STARTED == 未启动
    // ST_STARTED == 启动
    // ST_SHUTTING_DOWN == 关闭完成
    // ST_SHUTDOWN == 关闭
    // ST_TERMINATED == 中止
    // state 初始化时的默认值是:ST_NOT_STARTED
    if (state == ST_NOT_STARTED) { // true
        // 状态更新器
        // 比较NioEventLoop的state
        // 如果state = ST_NOT_STARTED 则更新为:ST_STARTED
        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) { // true
            boolean success = false;
            try {
                // 开始启动线程.
                doStartThread();
                success = true;
            } finally {
                // 如果没有成功,则重新设置state == ST_NOT_STARTED(未启动)
                if (!success) {
                    STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_NOT_STARTED);
                }
            } // end finally
        } // end if
    }// end if
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;20singlethreadeventexecutornioeventloopdostartthread&quot;&gt;(20).SingleThreadEventExecutor(NioEventLoop).doStartThread&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void doStartThread() {
    assert thread == null;
    // ******************************************************************
    // 另启动一个线程去初始化Thread 并调用:SingleThreadEventExecutor.run方法
    // ******************************************************************
    executor.execute(new Runnable() {
        @Override
        public void run() {
            // thread = Thread[nioEventLoopGroup-2-1,10,main]
            thread = Thread.currentThread();
            
            if (interrupted) { // false
                thread.interrupt();
            }

            boolean success = false;
            // 更新最后执行线程的时间
            updateLastExecutionTime();
            try {
                // *********************************************************
                // 调用:NioEventLoop.run()方法
                // *********************************************************
                SingleThreadEventExecutor.this.run();
                success = true;
            } catch (Throwable t) {
                logger.warn(&quot;Unexpected exception from an event executor: &quot;, t);
            } finally {
                for (;;) {
                    int oldState = state;
                    if (oldState &amp;gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(
                            SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) {
                        break;
                    }
                }

                // Check if confirmShutdown() was called at the end of the loop.
                if (success &amp;amp;&amp;amp; gracefulShutdownStartTime == 0) {
                    if (logger.isErrorEnabled()) {
                        logger.error(&quot;Buggy &quot; + EventExecutor.class.getSimpleName() + &quot; implementation; &quot; +
                                SingleThreadEventExecutor.class.getSimpleName() + &quot;.confirmShutdown() must &quot; +
                                &quot;be called before run() implementation terminates.&quot;);
                    }
                }

                try {
                    // Run all remaining tasks and shutdown hooks. At this point the event loop
                    // is in ST_SHUTTING_DOWN state still accepting tasks which is needed for
                    // graceful shutdown with quietPeriod.
                    for (;;) {
                        if (confirmShutdown()) {
                            break;
                        }
                    }

                    // Now we want to make sure no more tasks can be added from this point. This is
                    // achieved by switching the state. Any new tasks beyond this point will be rejected.
                    for (;;) {
                        int oldState = state;
                        if (oldState &amp;gt;= ST_SHUTDOWN || STATE_UPDATER.compareAndSet(
                                SingleThreadEventExecutor.this, oldState, ST_SHUTDOWN)) {
                            break;
                        }
                    }

                    // We have the final set of tasks in the queue now, no more can be added, run all remaining.
                    // No need to loop here, this is the final pass.
                    confirmShutdown();
                } finally {
                    try {
                        cleanup();
                    } finally {
                        // Lets remove all FastThreadLocals for the Thread as we are about to terminate and notify
                        // the future. The user may block on the future and once it unblocks the JVM may terminate
                        // and start unloading classes.
                        // See https://github.com/netty/netty/issues/6596.
                        FastThreadLocal.removeAll();

                        STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED);
                        threadLock.countDown();
                        int numUserTasks = drainTasks();
                        if (numUserTasks &amp;gt; 0 &amp;amp;&amp;amp; logger.isWarnEnabled()) {
                            logger.warn(&quot;An event executor terminated with &quot; +
                                    &quot;non-empty task queue (&quot; + numUserTasks + ')');
                        }
                        terminationFuture.setSuccess(null);
                    }
                }
            }
        }
    });
} // end doStartThread

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;21nioeventlooprun&quot;&gt;(21).NioEventLoop.run&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void run() {
    int selectCnt = 0;
    for (;;) {  // 死循环
        try {
            int strategy;
            try {
                // 判断是否有事件或者队列是否有数据
                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                // strategy = 0
                // 整个switch都不进入
                switch (strategy) { 
                case SelectStrategy.CONTINUE:
                    continue;

                case SelectStrategy.BUSY_WAIT:
                    // fall-through to SELECT since the busy-wait is not supported with NIO

                case SelectStrategy.SELECT:
                    long curDeadlineNanos = nextScheduledTaskDeadlineNanos();
                    if (curDeadlineNanos == -1L) {
                        curDeadlineNanos = NONE; // nothing on the calendar
                    }
                    nextWakeupNanos.set(curDeadlineNanos);
                    try {
                        if (!hasTasks()) {
                            strategy = select(curDeadlineNanos);
                        }
                    } finally {
                        // This update is just to help block unnecessary selector wakeups
                        // so use of lazySet is ok (no race condition)
                        nextWakeupNanos.lazySet(AWAKE);
                    }
                    // fall through
                default:
                }
            } catch (IOException e) {
                // If we receive an IOException here its because the Selector is messed up. Let's rebuild
                // the selector and retry. https://github.com/netty/netty/issues/8566
                rebuildSelector0();
                selectCnt = 0;
                handleLoopException(e);
                continue;
            }
            
            // 统计值进行自增
            selectCnt++;
            cancelledKeys = 0;
            needsToSelectAgain = false;
            final int ioRatio = this.ioRatio;
            boolean ranTasks;
            // ioRatio = 50 
            if (ioRatio == 100) { // false
                try {
                    if (strategy &amp;gt; 0) {
                        processSelectedKeys();
                    }
                } finally {
                    // Ensure we always run tasks.
                    ranTasks = runAllTasks();
                }
            } else if (strategy &amp;gt; 0) { // false(strategy == 0)
                final long ioStartTime = System.nanoTime();
                try {
                    processSelectedKeys();
                } finally {
                    // Ensure we always run tasks.
                    final long ioTime = System.nanoTime() - ioStartTime;
                    ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                }
            } else {
                // ************************************************
                // 运行所有的任务
                // ************************************************
                ranTasks = runAllTasks(0); // This will run the minimum number of tasks
            }

            if (ranTasks || strategy &amp;gt; 0) {
                if (selectCnt &amp;gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;amp;&amp;amp; logger.isDebugEnabled()) {
                    logger.debug(&quot;Selector.select() returned prematurely {} times in a row for Selector {}.&quot;,
                            selectCnt - 1, selector);
                }
                selectCnt = 0;
            } else if (unexpectedSelectorWakeup(selectCnt)) { // Unexpected wakeup (unusual case)
                selectCnt = 0;
            }
        } catch (CancelledKeyException e) {
            // Harmless exception - log anyway
            if (logger.isDebugEnabled()) {
                logger.debug(CancelledKeyException.class.getSimpleName() + &quot; raised by a Selector {} - JDK bug?&quot;,
                        selector, e);
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
        // Always handle shutdown even if the loop processing threw an exception.
        try {
            if (isShuttingDown()) {
                closeAll();
                if (confirmShutdown()) {
                    return;
                }
            }
        } catch (Throwable t) {
            handleLoopException(t);
        }
    }
} // end run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;22singlethreadeventexecutornioeventlooprunalltasks&quot;&gt;(22).SingleThreadEventExecutor(NioEventLoop).runAllTasks&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected boolean runAllTasks(long timeoutNanos) {
    // timeoutNanos == 0
    fetchFromScheduledTaskQueue();
    // 从队列里拉取任务
    Runnable task = pollTask();
    
    // 如果任务不为空,则返回
    if (task == null) { // false
        afterRunningAllTasks();
        return false;
    }

    // deadline = 0
    final long deadline = timeoutNanos &amp;gt; 0 ? ScheduledFutureTask.nanoTime() + timeoutNanos : 0;
    long runTasks = 0;
    long lastExecutionTime;
    
    
    for (;;) {
        // ********************************************************
        // 此时会回调:AbstractChannel$AbstractUnsafe.register0()
        //          ServerBootstrap$init
        // ********************************************************
        safeExecute(task);

        runTasks ++;
        
        if ((runTasks &amp;amp; 0x3F) == 0) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            if (lastExecutionTime &amp;gt;= deadline) {
                break;
            }
        }

        // 如果队列里一个有内容,那这个run是不是代表不会退出
        // 再从队列里取出一个任务出来
        // ServerBootstrap$init
        // ServerBootstrapAcceptor
        task = pollTask();
        if (task == null) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            break;
        }
    }

    afterRunningAllTasks();
    this.lastExecutionTime = lastExecutionTime;
    return true;
} // end runAllTasks


private boolean fetchFromScheduledTaskQueue() {
    // scheduledTaskQueue = null
    if (scheduledTaskQueue == null || scheduledTaskQueue.isEmpty()) {
        // 直接返回了
        return true;
    }
    long nanoTime = AbstractScheduledEventExecutor.nanoTime();
    for (;;) {
        Runnable scheduledTask = pollScheduledTask(nanoTime);
        if (scheduledTask == null) {
            return true;
        }
        if (!taskQueue.offer(scheduledTask)) {
            // No space left in the task queue add it back to the scheduledTaskQueue so we pick it up again.
            scheduledTaskQueue.add((ScheduledFutureTask&amp;lt;?&amp;gt;) scheduledTask);
            return false;
        }
    }
} // end fetchFromScheduledTaskQueue


protected Runnable pollTask() {
    assert inEventLoop();
    return pollTaskFrom(taskQueue);
}

protected static Runnable pollTaskFrom(Queue&amp;lt;Runnable&amp;gt; taskQueue) {
    for (;;) {
        // 从队列里拉取出数
        Runnable task = taskQueue.poll();
        // 如果任务不是唤醒任务,则返回任务
        if (task != WAKEUP_TASK) {
            return task;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;23abstractchannelnioserversocketchannelabstractunsaferegister0&quot;&gt;(23).AbstractChannel(NioServerSocketChannel)$AbstractUnsafe.register0&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void register0(ChannelPromise promise) {
    try {
        
        if (!promise.setUncancellable() || !ensureOpen(promise)) { // false
            return;
        }
        
        // firstRegistration
        boolean firstRegistration = neverRegistered;
       //  **********************************************************************
       // AbstractNioChannel$AbstractNioUnsafe.doRegister()
       // 调用子类的doRegister
       // 把Channel与Selector进行绑定
       //  **********************************************************************
       doRegister();
       neverRegistered = false;
       registered = true;
       
       // pipeline = io.netty.channel.DefaultChannelPipeline 
       // **********************************************************
       // 24.调用所有的:ChanelHandler.handlerAdded
       // **********************************************************
       pipeline.invokeHandlerAddedIfNeeded();


       safeSetSuccess(promise);
       
       // ****************************************
       // 28. DefaultChannelPipeline.fireChannelRegistered
       // 调用所有ChannelHandlerContext对应handler.channelRegistered
       // ****************************************
       pipeline.fireChannelRegistered();
       
       if (isActive()) { // false
           if (firstRegistration) {
                pipeline.fireChannelActive();
           } else if (config().isAutoRead()) {
                // This channel was registered before and autoRead() is set. This means we need to begin read
                // again so that we process inbound data.
                //
                // See https://github.com/netty/netty/issues/4805
                beginRead();
           } // end else if
       } // end if
    } catch (Throwable t) {
        // Close the channel directly to avoid FD leak.
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    }
} // end register0

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;24abstractniochannelnioserversocketchannelabstractniounsafedoregister&quot;&gt;(24).AbstractNioChannel(NioServerSocketChannel)$AbstractNioUnsafe.doRegister()&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected void doRegister() throws Exception {
    boolean selected = false;
    for (;;) {
        try {
            // **************************************************
            // 调用JDK原生的注册事件,将:Channel与Selector进行绑定
            // eventLoop().unwrappedSelector() = sun.nio.ch.KQueueSelectorImpl
            // javaChannel() = sun.nio.ch.ServerSocketChannelImpl
            // **************************************************
            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
            return;
        } catch (CancelledKeyException e) {
            if (!selected) {
                // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be
                // cached and not removed because no Select.select(..) operation was called yet.
                eventLoop().selectNow();
                selected = true;
            } else {
                // We forced a select operation on the selector before but the SelectionKey is still cached
                // for whatever reason. JDK bug ?
                throw e;
            }
        }
    } // end for
} // end doRegister

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;25defaultchannelpipelineinvokehandleraddedifneeded&quot;&gt;(25).DefaultChannelPipeline.invokeHandlerAddedIfNeeded&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final void invokeHandlerAddedIfNeeded() {
    assert channel.eventLoop().inEventLoop();
    // 第一次注册
    if (firstRegistration) { // true
        firstRegistration = false;
        // 
        callHandlerAddedForAllHandlers();
    }
} // end invokeHandlerAddedIfNeeded


private void callHandlerAddedForAllHandlers() {

    final PendingHandlerCallback pendingHandlerCallbackHead;
    synchronized (this) {
        assert !registered;
        registered = true;
        // 1. 获得实例变量
        // this.pendingHandlerCallbackHead = io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask
        // pendingHandlerCallbackHead = io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask
        pendingHandlerCallbackHead = this.pendingHandlerCallbackHead;
        
        // 2. 清空实例变量的值.
        this.pendingHandlerCallbackHead = null;
    }
    
    // task = io.netty.channel.DefaultChannelPipeline$PendingHandlerAddedTask
    PendingHandlerCallback task = pendingHandlerCallbackHead;
    while (task != null) {
        // 执行execute()方法
        task.execute();
        task = task.next;
    }
} // end callHandlerAddedForAllHandlers
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;26pendinghandleraddedtaskexecute&quot;&gt;(26).PendingHandlerAddedTask.execute&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void execute() {
    // 从上下文中获得:executeor
    // executor = io.netty.channel.nio.NioEventLoop
    EventExecutor executor = ctx.executor();
    
    if (executor.inEventLoop()) { // true
        // *******************************************
        // 调用handlerAdd方法
        // *******************************************
        callHandlerAdded0(ctx);
    } else {
        try {
            executor.execute(this);
        } catch (RejectedExecutionException e) {
            if (logger.isWarnEnabled()) {
                logger.warn(
                        &quot;Can't invoke handlerAdded() as the EventExecutor {} rejected it, removing handler {}.&quot;,
                        executor, ctx.name(), e);
            }
            atomicRemoveFromHandlerList(ctx);
            ctx.setRemoved();
        }
    }
} // end execute
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;27defaultchannelpipelinecallhandleradded0&quot;&gt;(27).DefaultChannelPipeline.callHandlerAdded0&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) {
    try {
        // 调用handlerAdded方法
        ctx.callHandlerAdded();
    } catch (Throwable t) {
        boolean removed = false;
        try {
            atomicRemoveFromHandlerList(ctx);
            ctx.callHandlerRemoved();
            removed = true;
        } catch (Throwable t2) {
            if (logger.isWarnEnabled()) {
                logger.warn(&quot;Failed to remove a handler: &quot; + ctx.name(), t2);
            }
        }
    
        if (removed) {
            fireExceptionCaught(new ChannelPipelineException(
                    ctx.handler().getClass().getName() +
                    &quot;.handlerAdded() has thrown an exception; removed.&quot;, t));
        } else {
            fireExceptionCaught(new ChannelPipelineException(
                    ctx.handler().getClass().getName() +
                    &quot;.handlerAdded() has thrown an exception; also failed to remove.&quot;, t));
        }
    } // end catch
} // end callHandlerAdded0

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;28defaultchannelhandlercontextcallhandleradded&quot;&gt;(28).DefaultChannelHandlerContext.callHandlerAdded&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final void callHandlerAdded() throws Exception {
    if (setAddComplete()) { //true
        //  handler为业务的ChannelHandler
        // io.netty.bootstrap.ServerBootstrap$1
        handler().handlerAdded(this);
    }
}

final boolean setAddComplete() {
    for (;;) {
        int oldState = handlerState;
        if (oldState == REMOVE_COMPLETE) {
            return false;
        }
        // 循环修改状态为:ADD_COMPLETE
        if (HANDLER_STATE_UPDATER.compareAndSet(this, oldState, ADD_COMPLETE)) {
            return true;
        }
    } // end 
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;29defaultchannelpipelinefirechannelregistered&quot;&gt;(29).DefaultChannelPipeline.fireChannelRegistered&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final ChannelPipeline fireChannelRegistered() {
    AbstractChannelHandlerContext.invokeChannelRegistered(head);
    return this;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;30abstractchannelhandlercontextinvokechannelregistered&quot;&gt;(30).AbstractChannelHandlerContext.invokeChannelRegistered&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static void invokeChannelRegistered(final AbstractChannelHandlerContext next) {
    // next = DefaultChannelPipeline$HeadContext#0
    // executor = io.netty.channel.nio.NioEventLoop
    EventExecutor executor = next.executor();
    if (executor.inEventLoop()) {// true
        // 
        next.invokeChannelRegistered();
    } else {
        executor.execute(new Runnable() {
            @Override
            public void run() {
                next.invokeChannelRegistered();
            }
        });
    }
} // end invokeChannelRegistered


private void invokeChannelRegistered() {
    if (invokeHandler()) { // true
        try {
            // 调用:channelRegistered(ChannelHandlerContext)方法
            ((ChannelInboundHandler) handler()).channelRegistered(this);
        } catch (Throwable t) {
            invokeExceptionCaught(t);
        }
    } else {
        fireChannelRegistered();
    }
} // end

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;31-总结&quot;&gt;(31). 总结&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 创建NioEventLoopGroup,内部持有多个:NioEventLoop/Selector.
2. 创建NioServerSocketChannel(内部持有:ChannelPipeline)
3. 调用:NioEventLoop.register(NioServerSocketChannel)
4. NioEventLoop委托给(NioServerSocketChannel)
    AbstractNioMessageChannel$NioMessageUnsafe.register
5. AbstractNioMessageChannel$NioMessageUnsafe.register
    5.1 创建Runnable -&amp;gt; AbstractChannel$AbstractUnsafe.register0
    5.2 委托给:NioEventLoop.execute(Runnable)异步提交任务.
6. NioEventLoop.execute
    6.1 添加Runnable到NioEventLoop.taskQueue中
    6.2 启动线程(SingleThreadEventExecutor.run())
7. NioEventLoop.run
    7.1 对事件进行处理,但没有事件时,执行所有的任务	
        (SingleThreadEventExecutor.runAllTasks)
    7.2 SingleThreadEventExecutor.runAllTasks会从SingleThreadEventExecutor.taskQueue中拉取任务,并运行.
8. SingleThreadEventExecutor.taskQueue任务有如下几个
    8.1 AbstractChannel$AbstractUnsafe.register0
    8.2 ServerBootstrap.init() 方法内部创建Runnable:Runnable(ServerBootstrapAcceptor)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Netty-ServerBootstrap.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Netty-ServerBootstrap.html</guid>
        
        <category>Netty</category>
        
        
      </item>
    
      <item>
        <title>Project Reactor Stream OOM排查</title>
        <description>&lt;blockquote&gt;
  &lt;font color=&quot;red&quot;&gt;注意:代码和分析日志都是经过处理了的&lt;/font&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;1生产上oom排查思路&quot;&gt;(1).生产上OOM排查思路&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;查日志,看能否查到蛛丝马迹?&lt;br /&gt;
 需要查N天的日志,因为,若是只有一两天的日志,可能会有误判,但是N天的OOM日志都提示在某一处代码,误判的概率性可性比较少.&lt;/li&gt;
  &lt;li&gt;模拟请求,以证实代码是否有问题?&lt;br /&gt;
 模拟并发请求,查看内存回收情况和线程回收情况,以确定代码是否存在泄露的可能性.&lt;/li&gt;
  &lt;li&gt;了解业务代码含义?&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;2查日志&quot;&gt;(2).查日志&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/project-reactor-stream/imgs/Project-ReactorStream-Bug.png&quot; alt=&quot;&amp;quot;Project Reactor Stream Bug&amp;quot;&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;连续查看4天的OOM日志,发现:线程栈信息都是停留在业务代码:TestService.saveConfig()方法上,由此可以判断:这个类的方法应该是有问题,否则,&lt;font color=&quot;red&quot;&gt;不可能巧合连续几天的OOM都是在这段代码上&lt;/font&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3了解业务&quot;&gt;(3).了解业务&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;用户通过UI配置延迟的定时任务信息&lt;/li&gt;
  &lt;li&gt;用户提交定时任务信息&lt;/li&gt;
  &lt;li&gt;
    &lt;font color=&quot;red&quot;&gt;取消以前创建的定时任务&lt;/font&gt;
  &lt;/li&gt;
  &lt;li&gt;从DB中获取所有启用的定时任务信息&lt;/li&gt;
  &lt;li&gt;
    &lt;font color=&quot;red&quot;&gt;重新创建定时任务&lt;/font&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;4模拟业务代码进行请求&quot;&gt;(4).模拟业务代码进行请求&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;刚接手项目,代码确实有很多的漏洞:&lt;br /&gt;
在并发的情况下,Disposable是单例的,会存在BUG.&lt;br /&gt;
定时任务是在单机创建的,代码是否有考虑健壮性?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;

import reactor.core.Disposable;
import reactor.core.publisher.Flux;
import reactor.core.scheduler.Schedulers;

public class ProjectReactorStreamOOMTest {
	// -Xmx10m -Xms10m
	public static void main(String[] args) throws Exception {
		// 模拟Tomcat每隔10秒,发起一次调用,总共500次请求
		TestService test = new TestService();
		int maxThreads = 500;
		for(int i = 0;i &amp;lt; maxThreads ; i++) {
			new Thread(()-&amp;gt;{test.saveConfig();}).start();
			TimeUnit.SECONDS.sleep(10);
		}
	}
}

class TestService {
    // 该对象是单例的,如何保证安全?
    // 定时任务这样创建?如何保证代码的健壮性?分布式部署下又该如何处理?
	private Disposable disposable;

	public void saveConfig() {
		// ...
		scheduleConfig();
		// ...
	}

	public void scheduleConfig() {
		// 取消订阅(Hold住上次创建的一批定时任务对象,进行释放)
		if (null != disposable) { 
			disposable.dispose();
		}
		// 从数据据库获取所有的定时任务信息,重新添加成定时任务
		List&amp;lt;Integer&amp;gt; list = mockFindList();
		disposable = 
		  Flux.fromIterable(list)  // 遍历集合
			.flatMap((item)-&amp;gt;{   // 对集合每一行数据进行加工和处理
				// 根据用户配置的时间进行定时任务的调度
				return Flux.interval(
				       Duration.ofMillis(item * 1000),Schedulers.newElastic(&quot;*****test***&quot;)  
				    ).doOnNext((i)-&amp;gt;{  // 当订阅时Publiser,在触发:onNext()之前,先触发该函数
				    	// 模拟耗时操作
				    	try {
				    		TimeUnit.SECONDS.sleep(1);
				    		System.out.println(Thread.currentThread().getName());
						} catch (Exception ignore) {
						} // end catch
				    });// end doOnNext
			}).subscribe();
	}

	public List&amp;lt;Integer&amp;gt; mockFindList() {
		List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
		// 模拟生产上149条数据
		for (int i = 0; i &amp;lt; 150; i++) {
			list.add(10);
		}
		return list;
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5通过jvisualvm监控结果图&quot;&gt;(5).通过jvisualvm监控结果图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/project-reactor-stream/imgs/Project-ReactorStream-Bug1.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/project-reactor-stream/imgs/Project-ReactorStream-Bug2.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/project-reactor-stream/imgs/Project-ReactorStream-Bug3.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/assets/project-reactor-stream/imgs/Project-ReactorStream-Bug4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6结论&quot;&gt;(6).结论&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;从业务的需求我们知道:&lt;font color=&quot;red&quot;&gt;用户修改定时任务信息时,是需要停止以前创建的定时任务&lt;/font&gt;,而,Project ReactorStream的dispose()方法有Bug.并没有把定时任务对象(Thread)给销毁掉.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;7rxjava是否存在有bug呢&quot;&gt;(7).RxJava是否存在有BUG呢?&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;通过监控和测试,发现RxJava并不存在该Bug,RxJava会及时释放掉定时任务实例(Thread)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
package help.lixin.samples;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import io.reactivex.Observable;
import io.reactivex.disposables.Disposable;
import io.reactivex.schedulers.Schedulers;

public class RxJavaTest {
	public static void main(String[] args) throws Exception {
		final ServiceTemp tmp = new ServiceTemp();
		int maxThreads = 500;
		for (int i = 0; i &amp;lt; maxThreads; i++) {
			new Thread(() -&amp;gt; {
				tmp.saveConfig();
			}).start();
			TimeUnit.SECONDS.sleep(15);
		}
	}
}

class ServiceTemp {
	private Disposable disposable;
	private AtomicInteger i = new AtomicInteger(0);

	public void saveConfig() {
		System.out.println(&quot;第&quot; + i.getAndIncrement() + &quot;次 tomcat请求&quot;);
		if (null != disposable &amp;amp;&amp;amp; !disposable.isDisposed()) {
			disposable.dispose();
		}
		List&amp;lt;Integer&amp;gt; list = values();
		disposable = Observable.fromIterable(list) //
				.flatMap((sleep) -&amp;gt; {
					return Observable.interval(sleep, TimeUnit.SECONDS, Schedulers.io()) //
							.doOnNext((i) -&amp;gt; {
						// mock 网络请求
						TimeUnit.SECONDS.sleep(1);
						// mock 网络请求
						DateFormat df = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss:SSS&quot;);
						System.out.println(
								Thread.currentThread().getName() + &quot;  &quot; + df.format(new Date()) + &quot; task: &quot; + sleep);
					});
				})
				.doOnError((e)-&amp;gt;{
					System.out.println(&quot;errpr: &quot;+e);
				})
				.subscribe();
	}

	public List&amp;lt;Integer&amp;gt; values() {
		List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;Integer&amp;gt;();
		for(int i=0;i&amp;lt;149;i++) {
			list.add(10);
		}
		return list;
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Netty-ProjectReactor-Bug.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Netty-ProjectReactor-Bug.html</guid>
        
        <category>ProjectReactorStream</category>
        
        
      </item>
    
      <item>
        <title>Netty源码(NioServerSocketChannel)</title>
        <description>&lt;h3 id=&quot;1nioserversocketchannel-类结构图&quot;&gt;(1).NioServerSocketChannel 类结构图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netty/imgs/NioServerSocketChannel.png&quot; alt=&quot;&amp;quot;NioServerSocketChannel类结构图&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2nioserversocketchannel初始化过程&quot;&gt;(2).NioServerSocketChannel初始化过程&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static final SelectorProvider DEFAULT_SELECTOR_PROVIDER = SelectorProvider.provider();


// 1.通过反射工厂创建该对象
public NioServerSocketChannel() {
    // 1.1 newSocket
    // 1.2 this
    this(newSocket(DEFAULT_SELECTOR_PROVIDER));
}


// 1.2 构造器
public NioServerSocketChannel(ServerSocketChannel channel) {
    // channel = sun.nio.ch.ServerSocketChannelImpl
    // 3.调用父类(AbstractNioMessageChannel/AbstractNioChannel/AbstractChannel)的构造器
    super(null, channel, SelectionKey.OP_ACCEPT);
    config = new NioServerSocketChannelConfig(this, javaChannel().socket());
}

// 1.1 创建:ServerSocketChannel
private static ServerSocketChannel newSocket(SelectorProvider provider) {
    try {
         return provider.openServerSocketChannel();
    } catch (IOException e) {
        throw new ChannelException(&quot;Failed to open a server socket.&quot;, e);
    }
} //end newSocket
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3abstractniomessagechannel&quot;&gt;(3).AbstractNioMessageChannel&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected AbstractNioMessageChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    // parent = null
    // ch = sun.nio.ch.ServerSocketChannelImpl
    // readInterestOp = SelectionKey.OP_ACCEPT(16)
    
    // 4. 调用父类(AbstractNioChannel)的构造器
    super(parent, ch, readInterestOp);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4abstractniochannel&quot;&gt;(4).AbstractNioChannel&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) {
    // parent = null
    // ch = sun.nio.ch.ServerSocketChannelImpl
    // readInterestOp = SelectionKey.OP_ACCEPT(16)
    
    // 5.调用父类(AbstractChannel)构造器
    super(parent);
    
    this.ch = ch;
   this.readInterestOp = readInterestOp;
    
    try {
        // 设置非阻塞
        ch.configureBlocking(false);
    } catch (IOException e) {
        try {
            // 有异常的情况下关闭
            ch.close();
        } catch (IOException e2) {
            logger.warn(&quot;Failed to close a partially initialized socket.&quot;, e2);
        }
        throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);
    } // end catch
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5abstractchannel&quot;&gt;(5).AbstractChannel&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected AbstractChannel(Channel parent) {
    // parent = null
    this.parent = parent;
    // 创建ChannelId
    id = newId();
    
    // 6.调用AbstractNioMessageChannel.newUnsafe() 创建Channel$Unsafe
    unsafe = newUnsafe();
    
    // 创建DefaultChannelPipeline
    pipeline = newChannelPipeline();
}

// 创建默认的ChannelPipeline
protected DefaultChannelPipeline newChannelPipeline() {
    return new DefaultChannelPipeline(this);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6abstractniomessagechannelnewunsafe&quot;&gt;(6).AbstractNioMessageChannel.newUnsafe&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// AbstractNioMessageChannel
protected AbstractNioUnsafe newUnsafe() {
    return new NioMessageUnsafe();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7nioserversocketchannel-初始化过程图解&quot;&gt;(7).NioServerSocketChannel 初始化过程图解&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netty/imgs/NioServerSocketChannel-Invoker.png&quot; alt=&quot;&amp;quot;NioServerSocketChannel调用过程&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;8nioserversocketchannel-初始化总结&quot;&gt;(8).NioServerSocketChannel 初始化总结&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 创建:ServerSocketChannel(sun.nio.ch.ServerSocketChannelImpl)
2. 创建:Unsafe对象(NioMessageUnsafe)
3. 创建:DefaultChannelPipeline对象
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Netty-NioServerSocketChannel.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Netty-NioServerSocketChannel.html</guid>
        
        <category>Netty</category>
        
        
      </item>
    
      <item>
        <title>Netty源码(EventLoopGroup)</title>
        <description>&lt;h3 id=&quot;1nioeventloopgroup继承关系图&quot;&gt;(1).NioEventLoopGroup继承关系图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;/assets/netty/imgs/NioEventLoopGroup.png&quot; alt=&quot;&amp;quot;NioEventLoopGroup类图&amp;quot;&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;2new-nioeventloopgroup&quot;&gt;(2).new NioEventLoopGroup&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;EventLoopGroup bossGroup = new NioEventLoopGroup(1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;3nioeventloopgroup-构造器&quot;&gt;(3).NioEventLoopGroup 构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public NioEventLoopGroup(int nThreads) {
    // nThreads = 1
    this(nThreads, (Executor) null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4nioeventloopgroup-构造器&quot;&gt;(4).NioEventLoopGroup 构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public NioEventLoopGroup(int nThreads, Executor executor) {
    // nThreads = 1
    // executor = null
    // 调用:SelectorProvider.provider() 获得一个:SelectorProvider
    this(nThreads, executor, SelectorProvider.provider());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;5nioeventloopgroup-构造器&quot;&gt;(5).NioEventLoopGroup 构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider) {
    // nThreads = 1
    // executor = null
    // 因为是mac:
    // selectorProvider = sun.nio.ch.KQueueSelectorProvider
    this(nThreads, executor, selectorProvider, DefaultSelectStrategyFactory.INSTANCE);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;6nioeventloopgroup-构造器&quot;&gt;(6).NioEventLoopGroup 构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public NioEventLoopGroup(int nThreads, Executor executor, final SelectorProvider selectorProvider,final SelectStrategyFactory selectStrategyFactory) {
    // nThreads = 1
    // executor = null
    // selectorProvider = sun.nio.ch.KQueueSelectorProvider
    // selectStrategyFactory = io.netty.channel.DefaultSelectStrategyFactory
    // 设置拒绝策略
    // 调用:MultithreadEventLoopGroup的构造器
    super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7multithreadeventloopgroup-构造器&quot;&gt;(7).MultithreadEventLoopGroup 构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
    // nThreads = 1
    // executor = null
    // args = SelectorProvider/SelectStrategyFactory/RejectedExecutionHandlers$1
    // args = [sun.nio.ch.KQueueSelectorProvider, io.netty.channel.DefaultSelectStrategyFactory, io.netty.util.concurrent.RejectedExecutionHandlers$1]
    // 调用父类MultithreadEventExecutorGroup的构造器
    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;8multithreadeventexecutorgroup-构造器&quot;&gt;(8).MultithreadEventExecutorGroup 构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) {
    // nThreads = 1
    // executor = null
    // args = [sun.nio.ch.KQueueSelectorProvider, io.netty.channel.DefaultSelectStrategyFactory, io.netty.util.concurrent.RejectedExecutionHandlers$1]
    this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;9multithreadeventexecutorgroup-构造器&quot;&gt;(9).MultithreadEventExecutorGroup 构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 属性域
EventExecutor[] children;
EventExecutorChooserFactory.EventExecutorChooser chooser;
AtomicInteger terminatedChildren = new AtomicInteger();
Promise&amp;lt;?&amp;gt; terminationFuture = new DefaultPromise(GlobalEventExecutor.INSTANCE);

// ********************************************
// 重点:
// ********************************************
protected MultithreadEventExecutorGroup(
            int nThreads, 
            Executor executor,
            EventExecutorChooserFactory chooserFactory, 
            Object... args) {
    // nThreads = 1
    // executor = null
    // chooserFactory = io.netty.util.concurrent.DefaultEventExecutorChooserFactory
    // args = [
   //   sun.nio.ch.KQueueSelectorProvider
   //   io.netty.channel.DefaultSelectStrategyFactory
   //   io.netty.util.concurrent.RejectedExecutionHandlers$1
   //]
    if (nThreads &amp;lt;= 0) {  // false
        throw new IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &amp;gt; 0)&quot;, nThreads));
    }
    
    // 用户没有指定线程池的情况下
    if (executor == null) { // true
        // 创建自定义的:Executor
        // 另开一节讲这部份的源码,先不纠结里面是什么
        executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
    }

    // EventExecutor[] children 为定义部份
    // 创建EventExecutor数组
    children = new EventExecutor[nThreads];

    for (int i = 0; i &amp;lt; nThreads; i ++) {
        boolean success = false;
        try {
            // ************************************************************
            // 先忽略,后面详解
            // 1. 委托给子类:NioEventLoopGroup去执行
            // [io.netty.channel.nio.NioEventLoop@6b81ce95]
            // ************************************************************
            children[i] = newChild(executor, args);
            success = true;
        } catch (Exception e) {
            // TODO: Think about if this is a good exception type
            throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e);
        } finally {
            if (!success) { // 执行不成功的处理
                for (int j = 0; j &amp;lt; i; j ++) {
                        children[j].shutdownGracefully();
                } //end for

                for (int j = 0; j &amp;lt; i; j ++) {
                    EventExecutor e = children[j];
                    try {
                        while (!e.isTerminated()) {
                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                        } //end while
                    } catch (InterruptedException interrupted) {
                        Thread.currentThread().interrupt();
                        break;
                    } //end catch
                }// end for
            } // end if
        } // finally
    } //end for

    // ************************************************************
    // 先忽略,后面详解
    //  chooser是一个选择器,可以从childern(NioEventLoop[])中选择一个:EventExecutor
    // chooserFactory.io.netty.util.concurrent.DefaultEventExecutorChooserFactory
    // chooser = io.netty.util.concurrent.DefaultEventExecutorChooserFactory$PowerOfTwoEventExecutorChooser
    // ************************************************************
    chooser = chooserFactory.newChooser(children);

    // 创建中止监听器
    final FutureListener&amp;lt;Object&amp;gt; terminationListener = new FutureListener&amp;lt;Object&amp;gt;() {
        @Override
        public void operationComplete(Future&amp;lt;Object&amp;gt; future) throws Exception {
            if (terminatedChildren.incrementAndGet() == children.length) {
                terminationFuture.setSuccess(null);
            }
        }
    }; //end 

    // 为所有的:NioEventLoop添加中止监听器
    for (EventExecutor e: children) {
            e.terminationFuture().addListener(terminationListener);
    }

    // 把NioEventLoop数组转换成Set集合.
    Set&amp;lt;EventExecutor&amp;gt; childrenSet = new LinkedHashSet&amp;lt;EventExecutor&amp;gt;(children.length);
    Collections.addAll(childrenSet, children);
    // 设置为只读的NioEventLoop
    readonlyChildren = Collections.unmodifiableSet(childrenSet);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;10nioeventloopgroupnewchild&quot;&gt;(10).NioEventLoopGroup.newChild&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected EventLoop newChild(Executor executor, Object... args) throws Exception {
    // executor = io.netty.util.concurrent.ThreadPerTaskExecutor
    // args = [
    //   sun.nio.ch.KQueueSelectorProvider
    //   io.netty.channel.DefaultSelectStrategyFactory
    //   io.netty.util.concurrent.RejectedExecutionHandlers$1
    // ]
    //  queueFactory = null;
    EventLoopTaskQueueFactory queueFactory = args.length == 4 ? (EventLoopTaskQueueFactory) args[3] : null;
    // ********************************************
    // 后面留一节专门讲NioEventLoop,先略过
    // ********************************************
    return new NioEventLoop(this, executor, (SelectorProvider) args[0],((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2], queueFactory);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;11总结&quot;&gt;(11).总结&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;NioEventLoopGroup实际是根据配置的nThreads,&lt;strong&gt;创建N个NioEventLoop&lt;/strong&gt;
NioEventLoopGroup和NioEventLoop都实现了:EventLoopGroup,相当于间两个类都间接的实现了ScheduledExecutorService(定时调度方法)和Iterable(迭代器).&lt;br /&gt;
&lt;strong&gt;而NioEventLoopGroup的大部份调度方法都是委派给:NioEventLoop去调用的.自己实际不执行任务定时任务的内容.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Netty-EventLoopGroup-2.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Netty-EventLoopGroup-2.html</guid>
        
        <category>Netty</category>
        
        
      </item>
    
      <item>
        <title>Netty EventLoopGroup接口分析</title>
        <description>&lt;h3 id=&quot;1查看nioeventloopgroup实现关系&quot;&gt;(1).查看NioEventLoopGroup实现关系&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 注意EventExecutorGroup
// 实现:java底层的:ScheduledExecutorService和Iterable
// 意味着有遍历和定时调度功能
io.netty.util.concurrent.EventExecutorGroup 
        implements 
        java.util.concurrent.ScheduledExecutorService,
        java.lang.Iterable        

io.netty.channel.EventLoopGroup 
        implements 
        io.netty.util.concurrent.EventExecutorGroup
        
io.netty.channel.MultithreadEventLoopGroup 
        extends 
        io.netty.util.concurrent.MultithreadEventExecutorGroup
        implements 
        io.netty.channel.EventLoopGroup        

io.netty.channel.nio.NioEventLoopGroup 
        extends 
        MultithreadEventLoopGroup

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;从NioEventLoopGroup的继承(实现)关系,可以看到:NioEventLoopGroup实现了JDK的:ScheduledExecutorService和Iterable.意味着:NioEventLoopGroup内部有定时任务功能和遍历功能.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;2查看接口eventexecutorgroup包含有哪些行为&quot;&gt;(2).查看接口EventExecutorGroup,包含有哪些行为?&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface EventExecutorGroup 
       // JDK自带的定时调度
       extends ScheduledExecutorService, 
       // JDK的容器遍历
       Iterable&amp;lt;EventExecutor&amp;gt; {
    
    boolean isShuttingDown();
    Future&amp;lt;?&amp;gt; shutdownGracefully();
    Future&amp;lt;?&amp;gt; shutdownGracefully(long quietPeriod, long timeout, TimeUnit unit);
   Future&amp;lt;?&amp;gt; terminationFuture();
   
   // ***************************************************************
   // Iterable行为方法
   EventExecutor next();
   // Iterable行为方法
   Iterator&amp;lt;EventExecutor&amp;gt; iterator();
   // ***************************************************************
   
   Future&amp;lt;?&amp;gt; submit(Runnable task);
   &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result);
   &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);
   ScheduledFuture&amp;lt;?&amp;gt; schedule(Runnable command, long delay, TimeUnit unit);
   &amp;lt;V&amp;gt; ScheduledFuture&amp;lt;V&amp;gt; schedule(Callable&amp;lt;V&amp;gt; callable, long delay, TimeUnit unit);
   ScheduledFuture&amp;lt;?&amp;gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);
   ScheduledFuture&amp;lt;?&amp;gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;EventExecutorGroup定义了遍历EventExecutor的方法,以及提交定时任务的方法.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;3查看eventloopgroup接口具有哪些行为&quot;&gt;(3).查看EventLoopGroup接口,具有哪些行为?&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface EventLoopGroup extends EventExecutorGroup {
    EventLoop next();
    // 
    ChannelFuture register(Channel channel);
    ChannelFuture register(ChannelPromise promise);
    ChannelFuture register(Channel channel, ChannelPromise promise);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;EventLoopGroup继承于:EventExecutorGroup(定时任务调度/遍历行为),并且定义了注册Channel的抽象行为.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;4分析multithreadeventloopgroup行为&quot;&gt;(4).分析MultithreadEventLoopGroup行为&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;MultithreadEventLoopGroup继承于MultithreadEventExecutorGroup,并实现了:EventLoopGroup.
这意味着:MultithreadEventLoopGroup需要实现:定时任务调度/注册Channel/遍历事件等行为.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;5总结&quot;&gt;(5).总结&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;从NioEventLoopGroup的接口行为来看.NioEventLoopGroup具备有:定时任务度功能/注册Channerl/遍历事件功能等&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Netty-EventLoopGroup-1.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Netty-EventLoopGroup-1.html</guid>
        
        <category>Netty</category>
        
        
      </item>
    
      <item>
        <title>Netty源码(EventLoop)</title>
        <description>&lt;h3 id=&quot;1nioeventloopgroupnewchild&quot;&gt;(1).NioEventLoopGroup.newChild&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected EventLoop newChild(Executor executor, Object... args) throws Exception {
    // args = [
    // sun.nio.ch.KQueueSelectorProvider
    // io.netty.channel.DefaultSelectStrategyFactory
    // io.netty.util.concurrent.RejectedExecutionHandlers$1
    // ]
    EventLoopTaskQueueFactory queueFactory = args.length == 4 ? (EventLoopTaskQueueFactory) args[3] : null;
    return new NioEventLoop( 
           // NioEventLoopGroup 
           this, 
           // io.netty.util.concurrent.ThreadPerTaskExecutor
           executor, 
           // sun.nio.ch.KQueueSelectorProvider
           (SelectorProvider) args[0],
           // io.netty.channel.DefaultSelectStrategyFactory
           ((SelectStrategyFactory) args[1]).newSelectStrategy(), 
           // io.netty.util.concurrent.RejectedExecutionHandlers$1
           (RejectedExecutionHandler) args[2], 
           // null
           queueFactory
    ); //end create NioEventLoop
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2nioeventloop构造器&quot;&gt;(2).NioEventLoop构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NioEventLoop(
        // parent = io.netty.channel.nio.NioEventLoopGroup
        NioEventLoopGroup parent, 
        // executor = io.netty.util.concurrent.ThreadPerTaskExecutor
        Executor executor, 
        // selectorProvider = sun.nio.ch.KQueueSelectorProvider
        SelectorProvider selectorProvider,
        // strategy = io.netty.channel.DefaultSelectStrategy
        SelectStrategy strategy, 
       // rejectedExecutionHandler = io.netty.util.concurrent.RejectedExecutionHandlers$1
       RejectedExecutionHandler rejectedExecutionHandler,
       // queueFactory = null
       EventLoopTaskQueueFactory queueFactory) {
    
    // 调用父类:SingleThreadEventLoop构造器
    super(    
        parent, 
        executor, 
        false, 
        // ********************************************
       newTaskQueue(queueFactory), 
       newTaskQueue(queueFactory),
       // ********************************************
        rejectedExecutionHandler
    ); // end super
    
    // sun.nio.ch.KQueueSelectorProvider
    this.provider = ObjectUtil.checkNotNull(selectorProvider, &quot;selectorProvider&quot;);
    // io.netty.channel.DefaultSelectStrategy
    this.selectStrategy = ObjectUtil.checkNotNull(strategy, &quot;selectStrategy&quot;);
    // **************************************************
    // 7.打开选择器(并为选择器配置自定义的结果队列)
    // **************************************************
    final SelectorTuple selectorTuple = openSelector();
    
    // Netty自定义的的Selector,内部包含有原生:Selector
    // selector = io.netty.channel.nio.SelectedSelectionKeySetSelector
    this.selector = selectorTuple.selector;
    
    // 未经包裹的JDK原生:Selector
    // unwrappedSelector = sun.nio.ch.KQueueSelectorImpl
    this.unwrappedSelector = selectorTuple.unwrappedSelector;
}

private static Queue&amp;lt;Runnable&amp;gt; newTaskQueue(
            EventLoopTaskQueueFactory queueFactory) {
    // queueFactory = null
    if (queueFactory == null) { // true
        // DEFAULT_MAX_PENDING_TASKS = 2147483647
        return newTaskQueue0(DEFAULT_MAX_PENDING_TASKS);
    }
    return queueFactory.newTaskQueue(DEFAULT_MAX_PENDING_TASKS);
}

 private static Queue&amp;lt;Runnable&amp;gt; newTaskQueue0(int maxPendingTasks) {
    // maxPendingTasks = 2147483647
    // true
    return maxPendingTasks == Integer.MAX_VALUE 
                ? PlatformDependent.&amp;lt;Runnable&amp;gt;newMpscQueue()
                : PlatformDependent.&amp;lt;Runnable&amp;gt;newMpscQueue(maxPendingTasks);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3singlethreadeventloop构造器&quot;&gt;(3).SingleThreadEventLoop构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected SingleThreadEventLoop(EventLoopGroup parent, Executor executor,
                                    boolean addTaskWakesUp, Queue&amp;lt;Runnable&amp;gt; taskQueue, Queue&amp;lt;Runnable&amp;gt; tailTaskQueue,
                                    RejectedExecutionHandler rejectedExecutionHandler) {
    // 调用父类(SingleThreadEventExecutor)构造器
    super(parent, executor, addTaskWakesUp, taskQueue, rejectedExecutionHandler);
    // tailTasks = org.jctools.queues.MpscUnboundedArrayQueue
    tailTasks = ObjectUtil.checkNotNull(tailTaskQueue, &quot;tailTaskQueue&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4singlethreadeventexecutor构造器&quot;&gt;(4).SingleThreadEventExecutor构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected SingleThreadEventExecutor(
        EventExecutorGroup parent, 
        Executor executor,
        boolean addTaskWakesUp, 
        Queue&amp;lt;Runnable&amp;gt; taskQueue,
        RejectedExecutionHandler rejectedHandler) {
            
    // 调用父类(AbstractScheduledEventExecutor)构造器
    super(parent);
    // addTaskWakesUp = false
    this.addTaskWakesUp = addTaskWakesUp;
    // maxPendingTasks = 2147483647
    this.maxPendingTasks = DEFAULT_MAX_PENDING_EXECUTOR_TASKS;
    // executor = io.netty.util.internal.ThreadExecutorMap$1
   this.executor = ThreadExecutorMap.apply(executor, this);
   // taskQueue = org.jctools.queues.MpscUnboundedArrayQueue
   this.taskQueue = ObjectUtil.checkNotNull(taskQueue, &quot;taskQueue&quot;);
   // rejectedExecutionHandler = io.netty.util.concurrent.RejectedExecutionHandlers$1
   this.rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, &quot;rejectedHandler&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5abstractscheduledeventexecutor构造器&quot;&gt;(5).AbstractScheduledEventExecutor构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected AbstractScheduledEventExecutor(EventExecutorGroup parent) {
    // 调用父类(AbstractEventExecutor)构造器
    super(parent);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6abstracteventexecutor构造器&quot;&gt;(6).AbstractEventExecutor构造器&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected AbstractEventExecutor(EventExecutorGroup parent) {
    this.parent = parent;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7nioeventloopopenselector&quot;&gt;(7).NioEventLoop.openSelector&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private SelectorTuple openSelector() {
        final Selector unwrappedSelector;
        try {
            //unwrappedSelector =  sun.nio.ch.KQueueSelectorImpl
            unwrappedSelector = provider.openSelector();
        } catch (IOException e) {
            throw new ChannelException(&quot;failed to open a new selector&quot;, e);
        }

        if (DISABLE_KEY_SET_OPTIMIZATION) { // false
            return new SelectorTuple(unwrappedSelector);
        }

         // 获取class:sun.nio.ch.SelectorImpl的信息
        // maybeSelectorImplClass = sun.nio.ch.SelectorImpl
        Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() {
            @Override
            public Object run() {
                try {
                    return Class.forName(
                            &quot;sun.nio.ch.SelectorImpl&quot;,
                            false,
                            PlatformDependent.getSystemClassLoader());
                } catch (Throwable cause) {
                    return cause;
                }
            }
        });

        // false
        if (!(maybeSelectorImplClass instanceof Class) ||
            // ensure the current selector implementation is what we can instrument.
            !((Class&amp;lt;?&amp;gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass())) {
            if (maybeSelectorImplClass instanceof Throwable) {
                Throwable t = (Throwable) maybeSelectorImplClass;
                logger.trace(&quot;failed to instrument a special java.util.Set into: {}&quot;, unwrappedSelector, t);
            }
            return new SelectorTuple(unwrappedSelector);
        }

        // selectorImplClass = sun.nio.ch.SelectorImpl
        final Class&amp;lt;?&amp;gt; selectorImplClass = (Class&amp;lt;?&amp;gt;) maybeSelectorImplClass;
        final SelectedSelectionKeySet selectedKeySet = new SelectedSelectionKeySet();

        
        // *************************************************
        // 为实例对象(sun.nio.ch.KQueueSelectorImpl)
        // 设置:selectedKeys/publicSelectedKeys属性指定为:自定义的结果存储集合(SelectedSelectionKeySet)里.
        // *************************************************
        Object maybeException = AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() {
            @Override
            public Object run() {
                try {
                    Field selectedKeysField = selectorImplClass.getDeclaredField(&quot;selectedKeys&quot;);
                    Field publicSelectedKeysField = selectorImplClass.getDeclaredField(&quot;publicSelectedKeys&quot;);

                    if (PlatformDependent.javaVersion() &amp;gt;= 9 &amp;amp;&amp;amp; PlatformDependent.hasUnsafe()) {
                        // Let us try to use sun.misc.Unsafe to replace the SelectionKeySet.
                        // This allows us to also do this in Java9+ without any extra flags.
                        long selectedKeysFieldOffset = PlatformDependent.objectFieldOffset(selectedKeysField);
                        long publicSelectedKeysFieldOffset =
                                PlatformDependent.objectFieldOffset(publicSelectedKeysField);

                        if (selectedKeysFieldOffset != -1 &amp;amp;&amp;amp; publicSelectedKeysFieldOffset != -1) {
                            PlatformDependent.putObject(
                                    unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);
                            PlatformDependent.putObject(
                                    unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);
                            return null;
                        }
                        // We could not retrieve the offset, lets try reflection as last-resort.
                    }

                    Throwable cause = ReflectionUtil.trySetAccessible(selectedKeysField, true);
                    if (cause != null) {
                        return cause;
                    }
                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, true);
                    if (cause != null) {
                        return cause;
                    }
                    
                    
                    // unwrappedSelector = sun.nio.ch.KQueueSelectorImpl
                    // sun.nio.ch.KQueueSelectorImpl.selectedKeys
                    // sun.nio.ch.KQueueSelectorImpl.publicSelectedKeys
                    selectedKeysField.set(unwrappedSelector, selectedKeySet);
                    publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);
                    return null;
                } catch (NoSuchFieldException e) {
                    return e;
                } catch (IllegalAccessException e) {
                    return e;
                }
            }
        });

        if (maybeException instanceof Exception) { // false
            selectedKeys = null;
            Exception e = (Exception) maybeException;
            logger.trace(&quot;failed to instrument a special java.util.Set into: {}&quot;, unwrappedSelector, e);
            return new SelectorTuple(unwrappedSelector);
        }

        // ****************************************************
        // SelectedSelectionKeySet 内部持有:多人java.nio.channels.SelectionKey
        // ****************************************************
        selectedKeys = selectedKeySet;
        
        logger.trace(&quot;instrumented a special java.util.Set into: {}&quot;, unwrappedSelector);
        return new SelectorTuple(
            // 未包裹的Selector
            // sun.nio.ch.KQueueSelectorImpl
            unwrappedSelector,
            // selectedKeys=[]
            // SelectedSelectionKeySetSelector 是java.nio.channels.Selector的实现类
            new SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet)
       ); //end new SelectorTuple
    }
    

// class SelectedSelectionKeySetSelector extends Selector {}
// class SelectedSelectionKeySet extends AbstractSet&amp;lt;SelectionKey&amp;gt; {}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;8selectedselectionkeysetselector&quot;&gt;(8).SelectedSelectionKeySetSelector&lt;/h3&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 该类会委托给:KQueueSelectorImpl进行处理
final class SelectedSelectionKeySetSelector extends Selector {
    private final SelectedSelectionKeySet selectionKeys;
    private final Selector delegate;

    SelectedSelectionKeySetSelector(
            Selector delegate, 
            SelectedSelectionKeySet selectionKeys) {
        // delegate = sun.nio.ch.KQueueSelectorImpl
        this.delegate = delegate;
       // selectionKeys = io.netty.channel.nio.SelectedSelectionKeySet
       this.selectionKeys = selectionKeys;
    }

    @Override
    public boolean isOpen() {
        return delegate.isOpen();
    }

    @Override
    public SelectorProvider provider() {
        return delegate.provider();
    }

    @Override
    public Set&amp;lt;SelectionKey&amp;gt; keys() {
        return delegate.keys();
    }

    @Override
    public Set&amp;lt;SelectionKey&amp;gt; selectedKeys() {
        return delegate.selectedKeys();
    }

    @Override
    public int selectNow() throws IOException {
        selectionKeys.reset();
        return delegate.selectNow();
    }

    @Override
    public int select(long timeout) throws IOException {
        selectionKeys.reset();
        return delegate.select(timeout);
    }

    @Override
    public int select() throws IOException {
        selectionKeys.reset();
        return delegate.select();
    }

    @Override
    public Selector wakeup() {
        return delegate.wakeup();
    }

    @Override
    public void close() throws IOException {
        delegate.close();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;9总结&quot;&gt;(9).总结&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;NioEventLoop构造时,会创建:JDK 的Selector以及无界队列.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 26 Oct 2020 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2020/10/26/Netty-EventLoop.html</link>
        <guid isPermaLink="true">http://localhost:4000/2020/10/26/Netty-EventLoop.html</guid>
        
        <category>Netty</category>
        
        
      </item>
    
  </channel>
</rss>
