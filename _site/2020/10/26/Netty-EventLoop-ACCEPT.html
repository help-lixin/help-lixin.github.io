<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Netty源码(EventLoop如何处理ACCEPT事件) - 李新的博客</title>
    <meta name="author"  content="李新">
    <meta name="description" content="Netty源码(EventLoop如何处理ACCEPT事件)">
    <meta name="keywords"  content="Netty">
    <!-- Open Graph -->
    <meta property="og:title" content="Netty源码(EventLoop如何处理ACCEPT事件) - 李新的博客">
    <meta property="og:type" content="website">
    <meta property="og:url" content="http://localhost:4000/2020/10/26/Netty-EventLoop-ACCEPT.html">
    <meta property="og:description" content="昵称码农，热爱技术&喜欢探索源码。很高兴能在这里与你分享我对技术和生活的思考。">
    <meta property="og:site_name" content="李新的博客">
    <link rel="stylesheet" href="//cdn.staticfile.org/normalize/6.0.0/normalize.min.css">
    <link rel="stylesheet" href="//at.alicdn.com/t/font_roc50gemkxpw4s4i.css">
    <link rel="stylesheet" href="/assets/css/github-markdown.css">
    <link rel="stylesheet" href="/assets/css/prism.css">
    <link rel="stylesheet" href="/assets/css/share.min.css">
    <link rel="stylesheet" href="/assets/css/app.min.css">
    <link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <script src="https://cdn.staticfile.org/jquery/3.2.1/jquery.min.js"></script>
	
	<!--
Author: Ray-Eldath
refer to:
 - http://docs.mathjax.org/en/latest/options/index.html
-->

	<script type="text/javascript" async src="https://cdn.bootcss.com/mathjax/2.7.2/MathJax.js?config=TeX-MML-AM_CHTML"></script>
	
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
		jax: ["input/TeX", "output/HTML-CSS"],
		tex2jax: {
			inlineMath: [ ["$", "$"] ],
			displayMath: [ ["$$", "$$"] ],
			skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
		},
		"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] }
      });
    </script>

	
    <!--
Author: Ray-Eldath
-->
<style>
    .markdown-body .anchor{
        float: left;
        margin-top: -8px;
        margin-left: -20px;
        padding-right: 4px;
        line-height: 1;
        opacity: 0;
    }
    
    .markdown-body .anchor .anchor-icon{
        font-size: 15px
    }
</style>
<script>
    $(document).ready(function() {
        let nodes = document.querySelector(".markdown-body").querySelectorAll("h1,h2,h3")
        for(let node of nodes) {
            var anchor = document.createElement("a")
            var anchorIcon = document.createElement("i")
            anchorIcon.setAttribute("class", "fa fa-anchor fa-lg anchor-icon")
            anchorIcon.setAttribute("aria-hidden", true)
            anchor.setAttribute("class", "anchor")
            anchor.setAttribute("href", "#" + node.getAttribute("id"))
            
            anchor.onmouseover = function() {
                this.style.opacity = "0.4"
            }
            
            anchor.onmouseout = function() {
                this.style.opacity = "0"
            }
            
            anchor.appendChild(anchorIcon)
            node.appendChild(anchor)
        }
    })
</script>
</head>


<body>
  <!--[if lt IE 10]>
<div class="alert-danger" role="alert">你的浏览器实在太太太旧了，放学别走，升级完浏览器再说！<a target="_blank" class="alert-link" href="http://browsehappy.com">立即升级</a></div>
<![endif]-->
  <input id="nm-switch" type="hidden" value="true"> <header class="g-header">
    <div class="g-logo">
      <a href="/"></a>
    </div>
    <i id="menu-toggle" class="iconfont icon-menu"></i>
    <nav class="g-nav">
        <ul>
            
            <li><a href="/">home</a></li>
            
            <li><a href="/tags.html">tags</a></li>
            
        </ul>
    </nav>
</header>


  <header
    class="g-banner post-header post-pattern-circuitBoard bgcolor-default post-no-cover"
    data-theme="default"
  >
    <div class="post-wrapper">
      <div class="post-tags">
        
          
            <a href="/tags.html#Netty" class="post-tag">Netty</a>
          
        
      </div>
      <h1>Netty源码(EventLoop如何处理ACCEPT事件)</h1>
      <div class="post-meta">
        <span class="post-meta-item"><i class="iconfont icon-author"></i>李新</span>
        <time class="post-meta-item" datetime="20-10-26"><i class="iconfont icon-date"></i>26 Oct 2020</time>
      </div>
    </div>
    
  </header>

  <div class="post-content visible">
    

    <article class="markdown-body">
      <h3 id="1bossgroupnioeventloop初始化完成了是怎么接受请求accept事件并把请求分发给workgroupnioeventloop的呢">(1).BossGroup(NioEventLoop)初始化完成了,是怎么接受请求(ACCEPT事件),并把请求分发给:WorkGroup(NioEventLoop)的呢?</h3>
<blockquote>
  <p>答案在:<font color="red">NioEventLoop.run()</font>方法里.</p>
</blockquote>

<h3 id="2nioeventlooprun">(2).NioEventLoop.run</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public final class NioEventLoop extends SingleThreadEventLoop {
    protected void run() {
        int selectCnt = 0;
        for (;;) {
            
            try {
                int strategy;
                try {
                    // strategy = -1;
                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());
                    switch (strategy) {
                    case SelectStrategy.CONTINUE:
                        continue;
                    case SelectStrategy.BUSY_WAIT:
                    // ******************************************
                    // 产生轮询
                    // ******************************************
                    case SelectStrategy.SELECT:
                        // curDeadlineNanos = -1
                        long curDeadlineNanos = nextScheduledTaskDeadlineNanos();
                        if (curDeadlineNanos == -1L) { // true
                            //  NONE = 9223372036854775807
                            curDeadlineNanos = NONE; // nothing on the calendar
                        }
                        // 
                        nextWakeupNanos.set(curDeadlineNanos);
                        try {
                            if (!hasTasks()) { //true
                                // **************************************
                                // strategy = -1
                                // 3. 调用Selector.select() 阻塞等待客户端的连接
                                // **************************************
                                strategy = select(curDeadlineNanos);
                            }
                        } finally {
                            nextWakeupNanos.lazySet(AWAKE);
                        }
                        // fall through
                    default:
                    }
                } catch (IOException e) {
                    rebuildSelector0();
                    selectCnt = 0;
                    handleLoopException(e);
                    continue;
                } //end catch

                selectCnt++;
                cancelledKeys = 0;
                needsToSelectAgain = false;
                final int ioRatio = this.ioRatio;
                boolean ranTasks;
                
                // ioRatio = 50
                if (ioRatio == 100) {
                    try {
                        if (strategy &gt; 0) {
                            processSelectedKeys();
                        }
                    } finally {
                        // Ensure we always run tasks.
                        ranTasks = runAllTasks();
                    }
                } else if (strategy &gt; 0) {
                    final long ioStartTime = System.nanoTime();
                    try {
                        // ******************************************
                        // 4. 处理Select事件
                        // ******************************************
                        processSelectedKeys();
                    } finally {
                        // Ensure we always run tasks.
                        // ioTime = 650326301514
                        final long ioTime = System.nanoTime() - ioStartTime;
                        // **************************************************
                        // 9. 运行所有的任务(SingleThreadEventExecutor.runAllTasks)
                        // **************************************************
                        ranTasks = runAllTasks(ioTime * (100 - ioRatio) / ioRatio);
                    }
                } else {
                    ranTasks = runAllTasks(0); // This will run the minimum number of tasks
                }

                if (ranTasks || strategy &gt; 0) {
                    if (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;&amp; logger.isDebugEnabled()) {
                        logger.debug("Selector.select() returned prematurely {} times in a row for Selector {}.",
                                selectCnt - 1, selector);
                    }
                    selectCnt = 0;
                } else if (unexpectedSelectorWakeup(selectCnt)) { // Unexpected wakeup (unusual case)
                    selectCnt = 0;
                }
            } catch (CancelledKeyException e) {
                // Harmless exception - log anyway
                if (logger.isDebugEnabled()) {
                    logger.debug(CancelledKeyException.class.getSimpleName() + " raised by a Selector {} - JDK bug?",
                            selector, e);
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }
            
            // Always handle shutdown even if the loop processing threw an exception.
            try {
                if (isShuttingDown()) {
                    closeAll();
                    if (confirmShutdown()) {
                        return;
                    }
                }
            } catch (Throwable t) {
                handleLoopException(t);
            }// end catch
            
        } // end for
    } // end run
}
</code></pre></div></div>
<h3 id="3nioeventloopselect">(3).NioEventLoop.select</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private int select(long deadlineNanos) throws IOException {
    // deadlineNanos = 9223372036854775807
    if (deadlineNanos == NONE) { // true
        // selector  = io.netty.channel.nio.SelectedSelectionKeySetSelector
        // ************************************************
        //  select()为阻塞方法
        //  阻塞等待客户端的连接.一旦发现有连接过来,就将事件存储到:
        //  SelectedSelectionKeySet里面
        // ************************************************
        return selector.select();
    }
    // Timeout will only be 0 if deadline is within 5 microsecs
    long timeoutMillis = deadlineToDelayNanos(deadlineNanos + 995000L) / 1000000L;
    return timeoutMillis &lt;= 0 ? selector.selectNow() : selector.select(timeoutMillis);
}
</code></pre></div></div>
<h3 id="4nioeventloopprocessselectedkeys">(4).NioEventLoop.processSelectedKeys</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void processSelectedKeys() {
    // selectedKeys = sun.nio.ch.SelectionKeyImpl
    if (selectedKeys != null) {
        processSelectedKeysOptimized();
    } else {
        processSelectedKeysPlain(selector.selectedKeys());
    }
}
</code></pre></div></div>
<h3 id="5-nioeventloopprocessselectedkeysoptimized">(5). NioEventLoop.processSelectedKeysOptimized</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void processSelectedKeysOptimized() {
    // *************************************************
    // NioEventLoop.select() 方法会将用户触发的事件添加到:
    // selectedKeys中
    // *************************************************
    // selectedKeys.size = 1 此时只有一个client连接上来了
    for (int i = 0; i &lt; selectedKeys.size; ++i) {
        // k = sun.nio.ch.SelectionKeyImpl
        // 获得对应下标的SelectionKey
        final SelectionKey k = selectedKeys.keys[i];
        // 立即将对应的key设置为空
        selectedKeys.keys[i] = null;
        
        // a = NioServerSocketChannel
        final Object a = k.attachment();
        
        if (a instanceof AbstractNioChannel) { // true
            processSelectedKey(k, (AbstractNioChannel) a);
        } else {
            @SuppressWarnings("unchecked")
            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;
            processSelectedKey(k, task);
        }
    
        if (needsToSelectAgain) { // false
            // null out entries in the array to allow to have it GC'ed once the Channel close
            // See https://github.com/netty/netty/issues/2363
            selectedKeys.reset(i + 1);
    
            selectAgain();
            i = -1;
        }
    }
}
</code></pre></div></div>
<h3 id="6nioeventloopprocessselectedkey">(6).NioEventLoop.processSelectedKey</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch) {
    //  k = sun.nio.ch.SelectionKeyImpl
    // ch = NioServerSocketChannel 
    
    // 获得NioServerSocketChannel内部的Unsafe对象
    // unsafe = AbstractNioMessageChannel$NioMessageUnsafe
    final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();

    if (!k.isValid()) { // false
        final EventLoop eventLoop;
        try {
            eventLoop = ch.eventLoop();
        } catch (Throwable ignored) {
            // If the channel implementation throws an exception because there is no event loop, we ignore this
            // because we are only trying to determine if ch is registered to this event loop and thus has authority
            // to close ch.
            return;
        }
        // Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop
        // and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is
        // still healthy and should not be closed.
        // See https://github.com/netty/netty/issues/5125
        if (eventLoop == this) {
            // close the channel if the key is not valid anymore
            unsafe.close(unsafe.voidPromise());
        }
        return;
    }// end if
    
    try {
        // readyOps = 16
        int readyOps = k.readyOps();
        // We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise
        // the NIO JDK channel implementation may throw a NotYetConnectedException.
        if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) { // false
            // remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking
            // See https://github.com/netty/netty/issues/924
            int ops = k.interestOps();
            ops &amp;= ~SelectionKey.OP_CONNECT;
            k.interestOps(ops);
    
            unsafe.finishConnect();
        }
    
        // Process OP_WRITE first as we may be able to write some queued buffers and so free memory.
        if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) { // false
            // Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write
            ch.unsafe().forceFlush();
        }
    
        // Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead
        // to a spin loop
        // true
        if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            // *****************************************************
            // 6. AbstractNioMessageChannel.NioMessageUnsafe.read()
            // *****************************************************
            unsafe.read();
        }
    } catch (CancelledKeyException ignored) {
        unsafe.close(unsafe.voidPromise());
    }
}
</code></pre></div></div>
<h3 id="7abstractniomessagechannelniomessageunsaferead">(7).AbstractNioMessageChannel.NioMessageUnsafe.read</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public void read() {
    assert eventLoop().inEventLoop();
    // config = NioServerSocketChannel$NioServerSocketChannelConfig
    final ChannelConfig config = config();
    // 一个日志ChannelHandler 和 ServerBootstrap$ServerBootstrapAcceptor
    // pipeline = DefaultChannelPipeline{(LoggingHandler#0 = io.netty.handler.logging.LoggingHandler), (ServerBootstrap$ServerBootstrapAcceptor#0 = io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor)}
    final ChannelPipeline pipeline = pipeline();
    
    // allocHandle = io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl
    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();
    allocHandle.reset(config);
    
        
    boolean closed = false;
    Throwable exception = null;
    try {
        try {
            do {
                // 调用:NioServerSocketChannel.doReadMessages
                // 读取消息
                int localRead = doReadMessages(readBuf);
                
                if (localRead == 0) { // false
                    break;
                }
                
                if (localRead &lt; 0) { // false
                    closed = true;
                    break;
                }
                
                
                // allocHandler = io.netty.channel.AdaptiveRecvByteBufAllocator$HandleImpl
                allocHandle.incMessagesRead(localRead);
            } while (allocHandle.continueReading()); // end do while
        } catch (Throwable t) {
            exception = t;
        } // end catch

        
        int size = readBuf.size();
        for (int i = 0; i &lt; size; i ++) {
            readPending = false;
            // ******************************************************
            // readBuf.get(i) = NioSocketChannel
            // 调用BoosGroup里配置的所有handler.fireChannelRead
            // 传递的NioSocketChannel是刚才:doReadMessages new出来的
            // ******************************************************
            // 8.ServerBootstrap$ServerBootstrapAcceptor.channelRead()
            pipeline.fireChannelRead(readBuf.get(i));
        } // end for
        
        // 清除集合中的数据
        readBuf.clear();
        // 标记读取完成
        allocHandle.readComplete();
        
        // ***************************************************
        // 调用pipeline上所有的ChannelHandler.channelReadComplete(ctx) 方法
        // ***************************************************
        pipeline.fireChannelReadComplete();
    
        if (exception != null) { // false
            closed = closeOnReadError(exception);
            pipeline.fireExceptionCaught(exception);
        }// end if
    
        if (closed) { // false
            inputShutdown = true;
            if (isOpen()) {
                close(voidPromise());
            } // end if
        }// end if
    } finally {
        // Check if there is a readPending which was not processed yet.
        // This could be for two reasons:
        // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method
        // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method
        //
        // See https://github.com/netty/netty/issues/2254

        if (!readPending &amp;&amp; !config.isAutoRead()) { // false
            removeReadOp();
        }
    } // end finally
}// end read
</code></pre></div></div>
<h3 id="8nioserversocketchanneldoreadmessages">(8).NioServerSocketChannel.doReadMessages</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected int doReadMessages(List&lt;Object&gt; buf) throws Exception {
    // buf=[]
    
    // **************************************************************
    // javaChannel = sun.nio.ch.ServerSocketChannelImpl
    // 调用:ServerSocketChannel.accept()方法
    // 返回一个:java.nio.channels.SocketChannel对象
    // **************************************************************
    java.nio.channels.SocketChannel ch = SocketUtils.accept(javaChannel());
    
    try {
        if (ch != null) {
            // 创建一个:io.netty.channel.socket.nio.NioSocketChannel
            // NioSocketChannel 内部持
            // Channel = NioServerSocketChannel
            // SocketChannel = SocketChannel
            // 添加到buf中
            buf.add(new NioSocketChannel(this, ch));
            return 1;
        }
    } catch (Throwable t) {
        logger.warn("Failed to create a new channel from an accepted socket.", t); 
        try {
            ch.close();
        } catch (Throwable t2) {
            logger.warn("Failed to close a socket.", t2);
        }
    }    
    return 0;
}
</code></pre></div></div>
<h3 id="9serverbootstrapserverbootstrapacceptorchannelread">(9).ServerBootstrap$ServerBootstrapAcceptor.channelRead</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>private final EventLoopGroup childGroup;
private final ChannelHandler childHandler;
private final Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions;
private final Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs;
private final Runnable enableAutoReadTask;

public void channelRead(ChannelHandlerContext ctx, Object msg) {
    // msg = NioSocketChannel
    // ctx = DefaultChannelHandlerContext
    final Channel child = (Channel) msg;
    
    // 为WorkGroup配置管道信息
    child.pipeline().addLast(childHandler);
    // 为WorkGroup配置options
    setChannelOptions(child, childOptions, logger);
    // 为WorkGroup配置atrributes
    setAttributes(child, childAttrs);
    
    try {
        // 向WorkGroup(EventLoopGroup[EventLoop])注册Channel
        childGroup.register(child).addListener(new ChannelFutureListener() {
            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                if (!future.isSuccess()) {
                    forceClose(child, future.cause());
                }
            }
        });
    } catch (Throwable t) {
        forceClose(child, t);
    }
} // end channelRead
</code></pre></div></div>
<h3 id="10nioeventlooprunalltasks">(10).NioEventLoop.runAllTasks</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protected boolean runAllTasks(long timeoutNanos) {
    // timeoutNanos = 650326301514
    
    fetchFromScheduledTaskQueue();
    // 拉取任务
    Runnable task = pollTask();
    if (task == null) { // true
        afterRunningAllTasks();
        return false;
    }
    
    final long deadline = timeoutNanos &gt; 0 ? ScheduledFutureTask.nanoTime() + timeoutNanos : 0;
    long runTasks = 0;
    long lastExecutionTime;
    for (;;) {
        safeExecute(task);
    
        runTasks ++;
    
        // Check timeout every 64 tasks because nanoTime() is relatively expensive.
        // XXX: Hard-coded value - will make it configurable if it is really a problem.
        if ((runTasks &amp; 0x3F) == 0) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            if (lastExecutionTime &gt;= deadline) {
                break;
            }
        }
    
        task = pollTask();
        if (task == null) {
            lastExecutionTime = ScheduledFutureTask.nanoTime();
            break;
        }
    }
    
    afterRunningAllTasks();
    this.lastExecutionTime = lastExecutionTime;
    return true;
}
</code></pre></div></div>
<h3 id="11accept过程图解">(11).ACCEPT过程图解</h3>
<p><img src="/assets/netty/imgs/ServerSocketChannel-ACCEPT-EVENT.png" alt="&quot;ACCEPT过程图解&quot;" /></p>

<h3 id="12总结">(12).总结</h3>
<ol>
  <li>NioEventLoop.run方法会不停的轮询.当返回的策略为:SelectStrategy.SELECT</li>
  <li>调用:SelectedSelectionKeySetSelector.select()方法,会阻塞方法继续往下执行,直到有事件进入.并把事件存储到:SelectedSelectionKeySet集合中(修改Selector的事件存储对象).</li>
  <li>遍历集合(SelectedSelectionKeySet)中所有的事件(SelectionKey.OP_ACCEPT)</li>
  <li>调用:AbstractNioMessageChannel.NioMessageUnsafe.read处理ACCEPT/READ事件</li>
  <li>调用:NioServerSocketChannel.doReadMessages方法,会委托给:ServerSocketChannel.accept,返回一个SocketChannel.</li>
  <li>调用:DefaultChannelPipeline.fireChannelRead,通知所有ChannelHandler.channelRead方法(ServerBootstrap.ServerBootstrapAcceptor.channelRead)
 6.1 为WorkGroup(EventLoop)添加ChannelHandler
 6.2 为WorkGroup(EventLoop)注册SocketChannel(子Channel)</li>
  <li>调用:DefaultChannelPipeline.fireChannelReadComplete.通知所有ChannelHandler.channelReadComplete方法</li>
</ol>

    </article>

    
  </div>

  <section class="author-detail">
    <section class="post-footer-item author-card">
      <div class="avatar">
        <img src="/assets/img/profile.png" alt="">
      </div>
      <div class="author-name" rel="author">李新</div>
      <div class="bio">
        <p>后端开发者，热爱技术&探索源码</p>
      </div>
      
      <ul class="sns-links">
        
        <li>
          <a href="//github.com/help-lixin" target="_blank">
                    <i class="iconfont icon-github"></i>
                </a>
        </li>
        
      </ul>
      
    </section>
    <section class="post-footer-item read-next">
      
      <div class="read-next-item">
        <a href="/2020/10/26/Netty-EventLoop-READ.html" class="read-next-link"></a>
        <section>
          <span>Netty源码(EventLoop如何处理READ事件)</span>
          <p>(1).Netty又是如何处理读写请求的呢?  代码的入口在:ServerBootstrap$ServerBoot...</p>
        </section>
        
     </div>
      

      
      <div class="read-next-item">
        <a href="/2020/10/26/Netty-ChannelPipeline.html" class="read-next-link"></a>
          <section>
            <span>Netty源码学习(ChannelPipeline)</span>
            <p>(1).ChannelPipeline说ChannelPipeline时,不得不说下以下几个接口:    io.n...</p>
          </section>
          
      </div>
      
    </section>
    
  </section>

  <footer class="g-footer">
  <section>李新的博客 ©
  
  
    2017
    -
  
  2020
  </section>
  <section>Powered by <a href="//jekyllrb.com">Jekyll</a> | <a href="https://github.com/kaeyleo/jekyll-theme-H2O">Theme H2O</a></section>
</footer>


  <script src="/assets/js/social-share.min.js"></script>
  <script>
    socialShare('.social-share', {
      sites: [
        
      ],
      wechatQrcodeTitle: "分享到微信朋友圈",
      wechatQrcodeHelper: '<p>扫码后点击右上角</p><p>将本文分享至朋友圈</p>'
    });
  </script>

  

  <script src="/assets/js/prism.js"></script>
  <script src="/assets/js/index.min.js"></script>
</body>

</html>
